// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { WebCryptoAlgorithmSuite, WebCryptoDefaultCryptographicMaterialsManager, getEncryptHelper, KeyringWebCrypto, needs, CommitmentPolicy, CommitmentPolicySuites, MessageFormat, } from '@aws-crypto/material-management-browser';
import { serializeFactory, aadFactory, concatBuffers, serializeSignatureInfo, FRAME_LENGTH, raw2der, Maximum, MessageIdLength, serializeMessageHeaderAuth, } from '@aws-crypto/serialize';
import { fromUtf8 } from '@aws-sdk/util-utf8-browser';
import { getWebCryptoBackend } from '@aws-crypto/web-crypto-backend';
const serialize = serializeFactory(fromUtf8);
const { messageAADContentString, messageAAD } = aadFactory(fromUtf8);
export async function _encrypt({ commitmentPolicy, maxEncryptedDataKeys }, cmm, plaintext, { suiteId, encryptionContext = {}, frameLength = FRAME_LENGTH, } = {}) {
    /* Precondition: _encrypt needs a valid commitmentPolicy. */
    needs(CommitmentPolicy[commitmentPolicy], 'Invalid commitment policy.');
    // buildEncrypt defaults this to false for backwards compatibility, so this is satisfied
    /* Precondition: _encrypt needs a valid maxEncryptedDataKeys. */
    needs(maxEncryptedDataKeys === false || maxEncryptedDataKeys >= 1, 'Invalid maxEncryptedDataKeys value.');
    /* Precondition: The frameLength must be less than the maximum frame size for browser encryption. */
    needs(frameLength > 0 && Maximum.FRAME_SIZE >= frameLength, `frameLength out of bounds: 0 > frameLength >= ${Maximum.FRAME_SIZE}`);
    const backend = await getWebCryptoBackend();
    if (!backend)
        throw new Error('No supported crypto backend');
    /* If the cmm is a Keyring, wrap it with WebCryptoDefaultCryptographicMaterialsManager. */
    cmm =
        cmm instanceof KeyringWebCrypto
            ? new WebCryptoDefaultCryptographicMaterialsManager(cmm)
            : cmm;
    // Subtle Crypto functions are all one-shot so all the plaintext needs to be available.
    const plaintextLength = plaintext.byteLength;
    const suite = suiteId && new WebCryptoAlgorithmSuite(suiteId);
    /* Precondition: Only request WebCryptoEncryptionMaterial for algorithm suites supported in commitmentPolicy. */
    CommitmentPolicySuites.isEncryptEnabled(commitmentPolicy, suite);
    const encryptionRequest = {
        suite,
        encryptionContext,
        plaintextLength,
        commitmentPolicy,
    };
    const material = await cmm.getEncryptionMaterials(encryptionRequest);
    /* Precondition: Only use WebCryptoEncryptionMaterial for algorithm suites supported in commitmentPolicy. */
    CommitmentPolicySuites.isEncryptEnabled(commitmentPolicy, material.suite);
    /* Precondition: _encrypt encryption materials must not exceed maxEncryptedDataKeys */
    needs(maxEncryptedDataKeys === false ||
        material.encryptedDataKeys.length <= maxEncryptedDataKeys, 'maxEncryptedDataKeys exceeded.');
    const { getEncryptInfo, subtleSign, dispose } = await getEncryptHelper(material);
    const versionString = MessageFormat[material.suite.messageFormat];
    const messageIdLength = parseInt(MessageIdLength[versionString], 10);
    /* Precondition UNTESTED: WebCrypto suites must result is some messageIdLength. */
    needs(messageIdLength > 0, 'Algorithm suite has unknown message format.');
    const messageId = await backend.randomValues(messageIdLength);
    const { ivLength } = material.suite;
    const { getSubtleEncrypt, keyCommitment } = await getEncryptInfo(messageId);
    const messageHeader = serialize.buildMessageHeader({
        suite: material.suite,
        encryptedDataKeys: material.encryptedDataKeys,
        encryptionContext: material.encryptionContext,
        messageId,
        frameLength,
        suiteData: keyCommitment,
    });
    const header = serialize.serializeMessageHeader(messageHeader);
    const headerIv = serialize.headerAuthIv(ivLength);
    const headerAuthTag = new Uint8Array(await getSubtleEncrypt(headerIv, header)(new Uint8Array(0)));
    // In the case of plaintextLength == 0 there still needs to be 1 frame.
    const numberOfFrames = Math.max(Math.ceil(plaintextLength / frameLength), 1);
    /* The final frame has a variable length.
     * The value needs to be known, but should only be calculated once.
     * So I calculate how much of a frame I should have at the end.
     * This value will NEVER be larger than the frameLength.
     */
    const finalFrameLength = plaintextLength - (numberOfFrames - 1) * frameLength;
    const bodyContent = [];
    for (let sequenceNumber = 1; numberOfFrames >= sequenceNumber; sequenceNumber += 1) {
        const frameIv = serialize.frameIv(ivLength, sequenceNumber);
        const isFinalFrame = sequenceNumber === numberOfFrames;
        const frameHeader = isFinalFrame
            ? serialize.finalFrameHeader(sequenceNumber, frameIv, finalFrameLength)
            : serialize.frameHeader(sequenceNumber, frameIv);
        const contentString = messageAADContentString({
            contentType: messageHeader.contentType,
            isFinalFrame,
        });
        const messageAdditionalData = messageAAD(messageId, contentString, sequenceNumber, isFinalFrame ? finalFrameLength : frameLength);
        /* Slicing an ArrayBuffer in a browser is suboptimal.
         * It makes a copy.s
         * So I just make a new view for the length of the frame.
         */
        const framePlaintext = new Uint8Array(plaintext.buffer, (sequenceNumber - 1) * frameLength, isFinalFrame ? finalFrameLength : frameLength);
        const cipherBufferAndAuthTag = await getSubtleEncrypt(frameIv, messageAdditionalData)(framePlaintext);
        bodyContent.push(frameHeader, cipherBufferAndAuthTag);
    }
    const result = concatBuffers(header, serializeMessageHeaderAuth({
        headerIv,
        headerAuthTag,
        messageHeader,
    }), ...bodyContent);
    dispose();
    if (typeof subtleSign === 'function') {
        const signatureArrayBuffer = await subtleSign(result);
        const derSignature = raw2der(new Uint8Array(signatureArrayBuffer), material.suite);
        const signatureInfo = serializeSignatureInfo(derSignature);
        return { result: concatBuffers(result, signatureInfo), messageHeader };
    }
    else {
        return { result: result, messageHeader };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW5jcnlwdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9lbmNyeXB0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG9FQUFvRTtBQUNwRSxzQ0FBc0M7QUFFdEMsT0FBTyxFQUNMLHVCQUF1QixFQUN2Qiw2Q0FBNkMsRUFJN0MsZ0JBQWdCLEVBQ2hCLGdCQUFnQixFQUNoQixLQUFLLEVBRUwsZ0JBQWdCLEVBQ2hCLHNCQUFzQixFQUN0QixhQUFhLEdBRWQsTUFBTSx5Q0FBeUMsQ0FBQTtBQUNoRCxPQUFPLEVBQ0wsZ0JBQWdCLEVBQ2hCLFVBQVUsRUFDVixhQUFhLEVBRWIsc0JBQXNCLEVBQ3RCLFlBQVksRUFDWixPQUFPLEVBQ1AsT0FBTyxFQUNQLGVBQWUsRUFDZiwwQkFBMEIsR0FDM0IsTUFBTSx1QkFBdUIsQ0FBQTtBQUM5QixPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sNEJBQTRCLENBQUE7QUFDckQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sZ0NBQWdDLENBQUE7QUFFcEUsTUFBTSxTQUFTLEdBQUcsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUE7QUFDNUMsTUFBTSxFQUFFLHVCQUF1QixFQUFFLFVBQVUsRUFBRSxHQUFHLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQTtBQWNwRSxNQUFNLENBQUMsS0FBSyxVQUFVLFFBQVEsQ0FDNUIsRUFBRSxnQkFBZ0IsRUFBRSxvQkFBb0IsRUFBaUIsRUFDekQsR0FBaUQsRUFDakQsU0FBcUIsRUFDckIsRUFDRSxPQUFPLEVBQ1AsaUJBQWlCLEdBQUcsRUFBRSxFQUN0QixXQUFXLEdBQUcsWUFBWSxNQUNWLEVBQUU7SUFFcEIsNERBQTREO0lBQzVELEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLDRCQUE0QixDQUFDLENBQUE7SUFFdkUsd0ZBQXdGO0lBQ3hGLGdFQUFnRTtJQUNoRSxLQUFLLENBQ0gsb0JBQW9CLEtBQUssS0FBSyxJQUFJLG9CQUFvQixJQUFJLENBQUMsRUFDM0QscUNBQXFDLENBQ3RDLENBQUE7SUFFRCxvR0FBb0c7SUFDcEcsS0FBSyxDQUNILFdBQVcsR0FBRyxDQUFDLElBQUksT0FBTyxDQUFDLFVBQVUsSUFBSSxXQUFXLEVBQ3BELGlEQUFpRCxPQUFPLENBQUMsVUFBVSxFQUFFLENBQ3RFLENBQUE7SUFFRCxNQUFNLE9BQU8sR0FBRyxNQUFNLG1CQUFtQixFQUFFLENBQUE7SUFDM0MsSUFBSSxDQUFDLE9BQU87UUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUE7SUFFNUQsMEZBQTBGO0lBQzFGLEdBQUc7UUFDRCxHQUFHLFlBQVksZ0JBQWdCO1lBQzdCLENBQUMsQ0FBQyxJQUFJLDZDQUE2QyxDQUFDLEdBQUcsQ0FBQztZQUN4RCxDQUFDLENBQUMsR0FBRyxDQUFBO0lBRVQsdUZBQXVGO0lBQ3ZGLE1BQU0sZUFBZSxHQUFHLFNBQVMsQ0FBQyxVQUFVLENBQUE7SUFDNUMsTUFBTSxLQUFLLEdBQUcsT0FBTyxJQUFJLElBQUksdUJBQXVCLENBQUMsT0FBTyxDQUFDLENBQUE7SUFFN0QsZ0hBQWdIO0lBQ2hILHNCQUFzQixDQUFDLGdCQUFnQixDQUFDLGdCQUFnQixFQUFFLEtBQUssQ0FBQyxDQUFBO0lBRWhFLE1BQU0saUJBQWlCLEdBQStCO1FBQ3BELEtBQUs7UUFDTCxpQkFBaUI7UUFDakIsZUFBZTtRQUNmLGdCQUFnQjtLQUNqQixDQUFBO0lBRUQsTUFBTSxRQUFRLEdBQUcsTUFBTSxHQUFHLENBQUMsc0JBQXNCLENBQUMsaUJBQWlCLENBQUMsQ0FBQTtJQUVwRSw0R0FBNEc7SUFDNUcsc0JBQXNCLENBQUMsZ0JBQWdCLENBQUMsZ0JBQWdCLEVBQUUsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFBO0lBRXpFLHNGQUFzRjtJQUN0RixLQUFLLENBQ0gsb0JBQW9CLEtBQUssS0FBSztRQUM1QixRQUFRLENBQUMsaUJBQWlCLENBQUMsTUFBTSxJQUFJLG9CQUFvQixFQUMzRCxnQ0FBZ0MsQ0FDakMsQ0FBQTtJQUVELE1BQU0sRUFBRSxjQUFjLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxHQUFHLE1BQU0sZ0JBQWdCLENBQ3BFLFFBQVEsQ0FDVCxDQUFBO0lBRUQsTUFBTSxhQUFhLEdBQUcsYUFBYSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFRLENBQUE7SUFDeEUsTUFBTSxlQUFlLEdBQUcsUUFBUSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQTtJQUNwRSxrRkFBa0Y7SUFDbEYsS0FBSyxDQUFDLGVBQWUsR0FBRyxDQUFDLEVBQUUsNkNBQTZDLENBQUMsQ0FBQTtJQUV6RSxNQUFNLFNBQVMsR0FBRyxNQUFNLE9BQU8sQ0FBQyxZQUFZLENBQUMsZUFBZSxDQUFDLENBQUE7SUFFN0QsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUE7SUFFbkMsTUFBTSxFQUFFLGdCQUFnQixFQUFFLGFBQWEsRUFBRSxHQUFHLE1BQU0sY0FBYyxDQUFDLFNBQVMsQ0FBQyxDQUFBO0lBRTNFLE1BQU0sYUFBYSxHQUFHLFNBQVMsQ0FBQyxrQkFBa0IsQ0FBQztRQUNqRCxLQUFLLEVBQUUsUUFBUSxDQUFDLEtBQUs7UUFDckIsaUJBQWlCLEVBQUUsUUFBUSxDQUFDLGlCQUFpQjtRQUM3QyxpQkFBaUIsRUFBRSxRQUFRLENBQUMsaUJBQWlCO1FBQzdDLFNBQVM7UUFDVCxXQUFXO1FBQ1gsU0FBUyxFQUFFLGFBQWE7S0FDekIsQ0FBQyxDQUFBO0lBRUYsTUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDLHNCQUFzQixDQUFDLGFBQWEsQ0FBQyxDQUFBO0lBRTlELE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUE7SUFDakQsTUFBTSxhQUFhLEdBQUcsSUFBSSxVQUFVLENBQ2xDLE1BQU0sZ0JBQWdCLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQzVELENBQUE7SUFFRCx1RUFBdUU7SUFDdkUsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsR0FBRyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQTtJQUM1RTs7OztPQUlHO0lBQ0gsTUFBTSxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsQ0FBQyxjQUFjLEdBQUcsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFBO0lBQzdFLE1BQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQTtJQUV0QixLQUNFLElBQUksY0FBYyxHQUFHLENBQUMsRUFDdEIsY0FBYyxJQUFJLGNBQWMsRUFDaEMsY0FBYyxJQUFJLENBQUMsRUFDbkI7UUFDQSxNQUFNLE9BQU8sR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxjQUFjLENBQUMsQ0FBQTtRQUMzRCxNQUFNLFlBQVksR0FBRyxjQUFjLEtBQUssY0FBYyxDQUFBO1FBQ3RELE1BQU0sV0FBVyxHQUFHLFlBQVk7WUFDOUIsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxjQUFjLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixDQUFDO1lBQ3ZFLENBQUMsQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLGNBQWMsRUFBRSxPQUFPLENBQUMsQ0FBQTtRQUNsRCxNQUFNLGFBQWEsR0FBRyx1QkFBdUIsQ0FBQztZQUM1QyxXQUFXLEVBQUUsYUFBYSxDQUFDLFdBQVc7WUFDdEMsWUFBWTtTQUNiLENBQUMsQ0FBQTtRQUNGLE1BQU0scUJBQXFCLEdBQUcsVUFBVSxDQUN0QyxTQUFTLEVBQ1QsYUFBYSxFQUNiLGNBQWMsRUFDZCxZQUFZLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxXQUFXLENBQzlDLENBQUE7UUFFRDs7O1dBR0c7UUFDSCxNQUFNLGNBQWMsR0FBRyxJQUFJLFVBQVUsQ0FDbkMsU0FBUyxDQUFDLE1BQU0sRUFDaEIsQ0FBQyxjQUFjLEdBQUcsQ0FBQyxDQUFDLEdBQUcsV0FBVyxFQUNsQyxZQUFZLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxXQUFXLENBQzlDLENBQUE7UUFDRCxNQUFNLHNCQUFzQixHQUFHLE1BQU0sZ0JBQWdCLENBQ25ELE9BQU8sRUFDUCxxQkFBcUIsQ0FDdEIsQ0FBQyxjQUFjLENBQUMsQ0FBQTtRQUVqQixXQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxzQkFBc0IsQ0FBQyxDQUFBO0tBQ3REO0lBRUQsTUFBTSxNQUFNLEdBQUcsYUFBYSxDQUMxQixNQUFNLEVBQ04sMEJBQTBCLENBQUM7UUFDekIsUUFBUTtRQUNSLGFBQWE7UUFDYixhQUFhO0tBQ2QsQ0FBQyxFQUNGLEdBQUcsV0FBVyxDQUNmLENBQUE7SUFFRCxPQUFPLEVBQUUsQ0FBQTtJQUVULElBQUksT0FBTyxVQUFVLEtBQUssVUFBVSxFQUFFO1FBQ3BDLE1BQU0sb0JBQW9CLEdBQUcsTUFBTSxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUE7UUFDckQsTUFBTSxZQUFZLEdBQUcsT0FBTyxDQUMxQixJQUFJLFVBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxFQUNwQyxRQUFRLENBQUMsS0FBSyxDQUNmLENBQUE7UUFDRCxNQUFNLGFBQWEsR0FBRyxzQkFBc0IsQ0FBQyxZQUFZLENBQUMsQ0FBQTtRQUMxRCxPQUFPLEVBQUUsTUFBTSxFQUFFLGFBQWEsQ0FBQyxNQUFNLEVBQUUsYUFBYSxDQUFDLEVBQUUsYUFBYSxFQUFFLENBQUE7S0FDdkU7U0FBTTtRQUNMLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLGFBQWEsRUFBRSxDQUFBO0tBQ3pDO0FBQ0gsQ0FBQyJ9