"use strict";
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports._importCryptoKey = exports.importCryptoKey = exports.deriveKeyCommitment = exports.buildAlgorithmForKDF = exports.WebCryptoKdf = exports.currySubtleFunction = exports.getDecryptionHelper = exports.getEncryptHelper = void 0;
const material_management_1 = require("@aws-crypto/material-management");
const serialize_1 = require("@aws-crypto/serialize");
const web_crypto_backend_1 = require("@aws-crypto/web-crypto-backend");
const bytes2_jwk_1 = require("./bytes2_jwk");
const getEncryptHelper = async (material) => {
    const backend = await (0, web_crypto_backend_1.getWebCryptoBackend)();
    /* Precondition: WebCryptoEncryptionMaterial must have a valid data key. */
    (0, material_management_1.needs)(material.hasValidKey(), 'Material has no CryptoKey.');
    const { signatureHash } = material.suite;
    const getEncryptInfo = currySubtleFunction(material, backend, 'encrypt');
    return Object.freeze({
        getEncryptInfo,
        subtleSign: signatureHash ? getSubtleSign : undefined,
        dispose,
    });
    async function getSubtleSign(data) {
        if (!signatureHash)
            throw new Error('Algorithm suite does not support signing.');
        const { signatureKey } = material;
        if (!signatureKey)
            throw new Error('Malformed Material.');
        const { privateKey } = signatureKey;
        if (!(0, material_management_1.isCryptoKey)(privateKey))
            throw new Error('Malformed Material.');
        const algorithm = { name: 'ECDSA', hash: { name: signatureHash } };
        return (0, web_crypto_backend_1.getNonZeroByteBackend)(backend).sign(algorithm, privateKey, data);
    }
    function dispose() {
        material.zeroUnencryptedDataKey();
    }
};
exports.getEncryptHelper = getEncryptHelper;
const getDecryptionHelper = async (material) => {
    const backend = await (0, web_crypto_backend_1.getWebCryptoBackend)();
    /* Precondition: WebCryptoDecryptionMaterial must have a valid data key. */
    (0, material_management_1.needs)(material.hasValidKey(), 'Material has no valid data key.');
    const { signatureHash } = material.suite;
    const getDecryptInfo = currySubtleFunction(material, backend, 'decrypt');
    return Object.freeze({
        getDecryptInfo,
        subtleVerify: signatureHash ? subtleVerify : undefined,
        dispose,
    });
    async function subtleVerify(signature, data) {
        if (!signatureHash)
            throw new Error('Algorithm suite does not support signing.');
        const { verificationKey } = material;
        if (!verificationKey)
            throw new Error('Malformed Material.');
        const { publicKey } = verificationKey;
        if (!(0, material_management_1.isCryptoKey)(publicKey))
            throw new Error('Malformed Material.');
        const algorithm = { name: 'ECDSA', hash: { name: signatureHash } };
        return (0, web_crypto_backend_1.getNonZeroByteBackend)(backend).verify(algorithm, publicKey, signature, data);
    }
    function dispose() {
        material.zeroUnencryptedDataKey();
    }
};
exports.getDecryptionHelper = getDecryptionHelper;
function currySubtleFunction(material, backend, subtleFunctionName) {
    /* Precondition: The material must have a CryptoKey. */
    (0, material_management_1.needs)(material.hasCryptoKey, 'Material must have a CryptoKey.');
    const cryptoKey = material.getCryptoKey();
    /* Precondition: The cryptoKey and backend must match in terms of Mixed vs Full support. */
    (0, material_management_1.needs)((0, material_management_1.isCryptoKey)(cryptoKey) === (0, web_crypto_backend_1.isFullSupportWebCryptoBackend)(backend), 'CryptoKey vs WebCrypto backend mismatch.');
    const { suite } = material;
    const { encryption: cipherName, ivLength, tagLength } = suite;
    return async (messageId, commitKey) => {
        /* This is very strange.
         * I would expect that I could await
         * the ternary and all would be fine.
         * But in testing, wallaby.js+webpack
         * compiles the typescript in such a way
         * that `deriveKey` is still
         * a promise by the time it gets to
         * the `data` below.
         * So I add awaits on the individual elements.
         */
        const { deriveKey, keyCommitment } = (0, material_management_1.isCryptoKey)(cryptoKey)
            ? await WebCryptoKdf((0, web_crypto_backend_1.getNonZeroByteBackend)(backend), material, cryptoKey, [subtleFunctionName], messageId, commitKey)
            : await Promise.all([
                WebCryptoKdf((0, web_crypto_backend_1.getNonZeroByteBackend)(backend), material, cryptoKey.nonZeroByteCryptoKey, [subtleFunctionName], messageId, commitKey),
                WebCryptoKdf((0, web_crypto_backend_1.getZeroByteSubtle)(backend), material, cryptoKey.zeroByteCryptoKey, [subtleFunctionName], messageId, commitKey),
            ]).then(([nonZeroByteCryptoKey, zeroByteCryptoKey]) => ({
                deriveKey: {
                    nonZeroByteCryptoKey: nonZeroByteCryptoKey.deriveKey,
                    zeroByteCryptoKey: zeroByteCryptoKey.deriveKey,
                },
                /* This works *because* the commitKey
                 * that is passed to both zero and nonzero is the same.
                 * If that ever changed, this might no longer be true.
                 */
                keyCommitment: nonZeroByteCryptoKey.keyCommitment,
            }));
        return (subtleFunctionName === 'encrypt'
            ? { getSubtleEncrypt: getSubtleFunction, keyCommitment }
            : getSubtleFunction);
        function getSubtleFunction(iv, additionalData) {
            /* Precondition: The length of the IV must match the WebCryptoAlgorithmSuite specification. */
            (0, material_management_1.needs)(iv.byteLength === ivLength, 'Iv length does not match algorithm suite specification');
            return async (data) => {
                if ((0, material_management_1.isCryptoKey)(deriveKey) && (0, web_crypto_backend_1.isFullSupportWebCryptoBackend)(backend)) {
                    const { subtle } = backend;
                    const algorithm = { name: cipherName, iv, additionalData, tagLength };
                    return subtle[subtleFunctionName](algorithm, deriveKey, data);
                }
                else if (!(0, material_management_1.isCryptoKey)(deriveKey) &&
                    !(0, web_crypto_backend_1.isFullSupportWebCryptoBackend)(backend)) {
                    const { nonZeroByteSubtle, zeroByteSubtle } = backend;
                    const { nonZeroByteCryptoKey, zeroByteCryptoKey } = deriveKey;
                    const algorithm = { name: cipherName, iv, additionalData, tagLength };
                    /* Precondition: The WebCrypto AES-GCM decrypt API expects the data *and* tag together.
                     * This means that on decrypt any amount of data less than tagLength is invalid.
                     * This also means that zero encrypted data will be equal to tagLength.
                     */
                    const dataByteLength = subtleFunctionName === 'decrypt'
                        ? data.byteLength - tagLength / 8
                        : data.byteLength;
                    (0, material_management_1.needs)(dataByteLength >= 0, 'Invalid data length.');
                    if (dataByteLength === 0) {
                        return zeroByteSubtle[subtleFunctionName](algorithm, zeroByteCryptoKey, data);
                    }
                    else {
                        return nonZeroByteSubtle[subtleFunctionName](algorithm, nonZeroByteCryptoKey, data);
                    }
                }
                // This should be impossible
                throw new Error('Unknown Error');
            };
        }
    };
}
exports.currySubtleFunction = currySubtleFunction;
async function WebCryptoKdf(subtle, material, cryptoKey, keyUsages, nonce, commitKey) {
    const { kdf, kdfHash, keyLength, encryption } = material.suite;
    /* Check for early return (Postcondition): No WebCrypto KDF, just return the unencrypted data key. */
    if (!kdf && !kdfHash)
        return { deriveKey: cryptoKey };
    const keyCommitment = await deriveKeyCommitment(subtle, material, cryptoKey, nonce, commitKey);
    // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams
    const kdfAlgorithm = buildAlgorithmForKDF(material.suite, nonce);
    const derivedKeyAlgorithm = { name: encryption, length: keyLength };
    const extractable = false;
    const deriveKey = await subtle.deriveKey(
    // types need to be updated see: https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams
    kdfAlgorithm, cryptoKey, derivedKeyAlgorithm, extractable, keyUsages);
    /* Postcondition: The derived key must conform to the algorith suite specification. */
    (0, material_management_1.needs)((0, material_management_1.isValidCryptoKey)(deriveKey, material), 'Invalid derived key');
    return { deriveKey, keyCommitment };
}
exports.WebCryptoKdf = WebCryptoKdf;
function buildAlgorithmForKDF(suite, nonce) {
    const { kdf, kdfHash, commitmentLength, saltLengthBytes } = suite;
    /* Precondition: Valid HKDF values must exist for browsers. */
    (0, material_management_1.needs)(kdf === 'HKDF' && kdfHash && nonce instanceof Uint8Array, 'Invalid HKDF values.');
    if (suite.commitment === 'NONE') {
        /* Precondition: The message ID length must match the specification. */
        (0, material_management_1.needs)(nonce.byteLength === serialize_1.MessageIdLength.V1, 'Message id length does not match specification.');
        const info = (0, serialize_1.kdfInfo)(suite.id, nonce);
        // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams
        return {
            name: kdf,
            hash: { name: kdfHash },
            info,
            salt: new Uint8Array(),
        };
    }
    /* Precondition UNTESTED: The suite must be well structured. */
    (0, material_management_1.needs)(suite.commitment === 'KEY' && commitmentLength && saltLengthBytes, 'Malformed suite data.');
    /* Precondition: The message id length must match the algorithm suite.
     * I am using the message id here,
     * but I must have enough entropy!
     */
    (0, material_management_1.needs)(nonce.byteLength === saltLengthBytes, 'Message id length does not match specification.');
    const { keyLabel: info } = (0, serialize_1.kdfCommitKeyInfo)(suite);
    const salt = nonce;
    // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams
    return {
        name: kdf,
        hash: { name: kdfHash },
        info,
        salt,
    };
}
exports.buildAlgorithmForKDF = buildAlgorithmForKDF;
async function deriveKeyCommitment(subtle, material, cryptoKey, nonce, commitKey) {
    const { suite } = material;
    const { kdf, kdfHash, commitmentLength, saltLengthBytes, commitment } = suite;
    /* Check for early return (Postcondition): Algorithm suites without commitment do not have a commitment. */
    if (commitment === 'NONE') {
        /* Postcondition: Non-committing WebCrypto algorithm suites *must* not have a commitment. */
        (0, material_management_1.needs)(!commitKey, 'Commitment not supported.');
        return;
    }
    /* Precondition UNTESTED: Only support key commitment. */
    (0, material_management_1.needs)(commitment === 'KEY' && commitmentLength && saltLengthBytes, 'Malformed suite data.');
    /* Precondition: Commit key requires 256 bits of entropy. */
    (0, material_management_1.needs)(nonce.byteLength === saltLengthBytes, 'Nonce is not the correct length for committed algorithm suite.');
    /* Precondition UNTESTED: Valid HKDF values must exist for commit key. */
    (0, material_management_1.needs)(kdf === 'HKDF' && kdfHash && nonce instanceof Uint8Array, 'Invalid HKDF values.');
    const { commitLabel: info } = (0, serialize_1.kdfCommitKeyInfo)(material.suite);
    /* In a more perfect world,
     * I would use `deriveBits`.
     * However I _know_ that deriveKey exists,
     * and is already used everywhere.
     * This is ugly here,
     * but is less churn to write today.
     * Also, deriveKey is slightly safer
     * for the actual key used.
     * Since both the commit key
     * and the kdf key come from the same root,
     * I *must* give this permission
     * to this root key.
     * This means that if the root key has `deriveBits`,
     * then I have effectively given `export`
     * to the operational derived key.
     * Because while the root key can not be exported,
     * the derived key could.
     * This is a thin reason, because you could just
     * create your own exportable key,
     * but, every little bit helps.
     */
    const keyCommitAlgorithm = {
        name: kdf,
        hash: { name: kdfHash },
        info,
        salt: nonce,
    };
    const derivedKeyAlgorithm = {
        name: suite.encryption,
        length: commitmentLength,
    };
    const extractable = true;
    const deriveKey = await subtle.deriveKey(
    // types need to be updated see: https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams
    keyCommitAlgorithm, cryptoKey, derivedKeyAlgorithm, extractable, 
    /* Something has to go here. */
    ['encrypt']);
    const keyCommitment = new Uint8Array(await subtle.exportKey('raw', deriveKey));
    const isDecrypt = material instanceof material_management_1.WebCryptoDecryptionMaterial;
    /* Precondition: If material is WebCryptoDecryptionMaterial the key commitments *must* match.
     * Ideally this will be checked _before_ the data key is derived
     * because then the decryption key is never even derived.
     * But for WebCrypto this is a bit hard,
     * because of legacy browsers and the lack of zero byte support.
     */
    (0, material_management_1.needs)((isDecrypt &&
        commitKey &&
        portableTimingSafeEqual(commitKey, keyCommitment)) ||
        (!isDecrypt && !commitKey), isDecrypt ? 'Commitment does not match.' : 'Invalid arguments.');
    return keyCommitment;
}
exports.deriveKeyCommitment = deriveKeyCommitment;
async function importCryptoKey(backend, material, keyUsages = [(0, material_management_1.keyUsageForMaterial)(material)]) {
    if ((0, web_crypto_backend_1.isFullSupportWebCryptoBackend)(backend)) {
        return _importCryptoKey(backend.subtle, material, keyUsages);
    }
    else {
        return Promise.all([
            _importCryptoKey((0, web_crypto_backend_1.getNonZeroByteBackend)(backend), material, keyUsages),
            _importCryptoKey((0, web_crypto_backend_1.getZeroByteSubtle)(backend), material, keyUsages),
        ]).then(([nonZeroByteCryptoKey, zeroByteCryptoKey]) => ({
            nonZeroByteCryptoKey,
            zeroByteCryptoKey,
        }));
    }
}
exports.importCryptoKey = importCryptoKey;
async function _importCryptoKey(subtle, material, keyUsages = [(0, material_management_1.keyUsageForMaterial)(material)]) {
    const { suite } = material;
    const extractable = false;
    const udk = (0, material_management_1.unwrapDataKey)(material.getUnencryptedDataKey());
    if (suite.kdf) {
        /* For several browsers, import for a key to derive with HKDF
         * *must* be raw.  This may cause some compatibility issues
         * with browsers that need a zero byte gcm fallback.
         */
        const format = 'raw';
        const algorithm = { name: suite.kdf, length: suite.keyLength };
        return subtle.importKey(format, udk, algorithm, extractable, keyUsages);
    }
    else {
        const format = 'jwk';
        const algorithm = { name: suite.encryption, length: suite.keyLength };
        const jwk = (0, bytes2_jwk_1.bytes2JWK)(udk);
        return subtle.importKey(format, jwk, algorithm, extractable, keyUsages);
    }
}
exports._importCryptoKey = _importCryptoKey;
function portableTimingSafeEqual(a, b) {
    /* It is *possible* that a runtime could optimize this constant time function.
     * Adding `eval` could prevent the optimization, but this is no guarantee.
     * The eval below is commented out
     * because if a browser is using a Content Security Policy with `'unsafe-eval'`
     * it would fail on this eval.
     * The value in attempting to ensure that this function is not optimized
     * is not worth the cost of making customers allow `'unsafe-eval'`.
     * If you want to copy this function for your own use,
     * please review the timing-attack link above.
     * Side channel attacks are pernicious and subtle.
     */
    // eval('') // eslint-disable-line no-eval
    /* Check for early return (Postcondition) UNTESTED: Size is well-know information
     * and does not leak information about contents.
     */
    if (a.byteLength !== b.byteLength)
        return false;
    let diff = 0;
    for (let i = 0; i < b.length; i++) {
        diff |= a[i] ^ b[i];
    }
    return diff === 0;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0ZXJpYWxfaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9tYXRlcmlhbF9oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxvRUFBb0U7QUFDcEUsc0NBQXNDOzs7QUFFdEMseUVBV3dDO0FBQ3hDLHFEQUk4QjtBQUU5Qix1RUFNdUM7QUFFdkMsNkNBQXdDO0FBaUNqQyxNQUFNLGdCQUFnQixHQUFxQixLQUFLLEVBQ3JELFFBQXFDLEVBQ3JDLEVBQUU7SUFDRixNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUEsd0NBQW1CLEdBQUUsQ0FBQTtJQUUzQywyRUFBMkU7SUFDM0UsSUFBQSwyQkFBSyxFQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsRUFBRSw0QkFBNEIsQ0FBQyxDQUFBO0lBRTNELE1BQU0sRUFBRSxhQUFhLEVBQUUsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFBO0lBQ3hDLE1BQU0sY0FBYyxHQUFHLG1CQUFtQixDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUE7SUFDeEUsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQ25CLGNBQWM7UUFDZCxVQUFVLEVBQUUsYUFBYSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLFNBQVM7UUFDckQsT0FBTztLQUNSLENBQUMsQ0FBQTtJQUVGLEtBQUssVUFBVSxhQUFhLENBQUMsSUFBZ0I7UUFDM0MsSUFBSSxDQUFDLGFBQWE7WUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsQ0FBQyxDQUFBO1FBQzlELE1BQU0sRUFBRSxZQUFZLEVBQUUsR0FBRyxRQUFRLENBQUE7UUFDakMsSUFBSSxDQUFDLFlBQVk7WUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUE7UUFDekQsTUFBTSxFQUFFLFVBQVUsRUFBRSxHQUFHLFlBQVksQ0FBQTtRQUNuQyxJQUFJLENBQUMsSUFBQSxpQ0FBVyxF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