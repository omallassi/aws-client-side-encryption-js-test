"use strict";
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebCryptoDefaultCryptographicMaterialsManager = void 0;
const material_management_1 = require("@aws-crypto/material-management");
const serialize_1 = require("@aws-crypto/serialize");
const web_crypto_backend_1 = require("@aws-crypto/web-crypto-backend");
const util_base64_browser_1 = require("@aws-sdk/util-base64-browser");
/**
 * The WebCryptoDefaultCryptographicMaterialsManager is a specific implementation of the CryptographicMaterialsManager.
 * New cryptography materials managers SHOULD extend from WebCryptoMaterialsManager.
 * Users should never need to create an instance of a WebCryptoDefaultCryptographicMaterialsManager.
 */
class WebCryptoDefaultCryptographicMaterialsManager {
    constructor(keyring) {
        /* Precondition: keyrings must be a KeyringWebCrypto. */
        (0, material_management_1.needs)(keyring instanceof material_management_1.KeyringWebCrypto, 'Unsupported type.');
        (0, material_management_1.readOnlyProperty)(this, 'keyring', keyring);
    }
    async getEncryptionMaterials({ suite, encryptionContext, commitmentPolicy, }) {
        suite =
            suite ||
                new material_management_1.WebCryptoAlgorithmSuite(material_management_1.CommitmentPolicySuites[commitmentPolicy].defaultAlgorithmSuite);
        /* Precondition: WebCryptoDefaultCryptographicMaterialsManager must reserve the ENCODED_SIGNER_KEY constant from @aws-crypto/serialize.
         * A CryptographicMaterialsManager can change entries to the encryptionContext
         * but changing these values has consequences.
         * The DefaultCryptographicMaterialsManager uses the value in the encryption context to store public signing key.
         * If the caller is using this value in their encryption context the Default CMM is probably not the CMM they want to use.
         */
        (0, material_management_1.needs)(!Object.prototype.hasOwnProperty.call(encryptionContext, serialize_1.ENCODED_SIGNER_KEY), `Reserved encryptionContext value ${serialize_1.ENCODED_SIGNER_KEY} not allowed.`);
        const material = await this.keyring.onEncrypt(await this._initializeEncryptionMaterial(suite, encryptionContext));
        /* Postcondition: The WebCryptoEncryptionMaterial must contain a valid dataKey.
         * This verifies that the data key matches the algorithm suite specification
         * and that the unencrypted data key is non-NULL.
         * See: cryptographic_materials.ts, `getUnencryptedDataKey`
         */
        (0, material_management_1.needs)(material.hasValidKey(), 'Unencrypted data key is invalid.');
        /* Postcondition: The WebCryptoEncryptionMaterial must contain at least 1 EncryptedDataKey. */
        (0, material_management_1.needs)(material.encryptedDataKeys.length, 'No EncryptedDataKeys: the ciphertext can never be decrypted.');
        return material;
    }
    async decryptMaterials({ suite, encryptedDataKeys, encryptionContext, }) {
        const material = await this.keyring.onDecrypt(await this._initializeDecryptionMaterial(suite, encryptionContext), encryptedDataKeys.slice());
        /* Postcondition: The WebCryptoDecryptionMaterial must contain a valid dataKey.
         * See: cryptographic_materials.ts, `getUnencryptedDataKey` also verifies
         * that the unencrypted data key has not been manipulated,
         * that the data key matches the algorithm suite specification
         * and that the unencrypted data key is non-NULL.
         */
        (0, material_management_1.needs)(material.hasValidKey(), 'Unencrypted data key is invalid.');
        return material;
    }
    async _initializeEncryptionMaterial(suite, encryptionContext) {
        const { signatureCurve: namedCurve } = suite;
        /* Check for early return (Postcondition): The WebCryptoAlgorithmSuite specification must support a signatureCurve to generate a signing key. */
        if (!namedCurve)
            return new material_management_1.WebCryptoEncryptionMaterial(suite, encryptionContext);
        const backend = await (0, web_crypto_backend_1.getWebCryptoBackend)();
        const subtle = (0, web_crypto_backend_1.getNonZeroByteBackend)(backend);
        const webCryptoAlgorithm = { name: 'ECDSA', namedCurve };
        const extractable = false;
        const usages = ['sign'];
        const format = 'raw';
        const { publicKey, privateKey } = (await subtle.generateKey(webCryptoAlgorithm, extractable, usages));
        const publicKeyBytes = await subtle.exportKey(format, publicKey);
        const compressPoint = material_management_1.SignatureKey.encodeCompressPoint(new Uint8Array(publicKeyBytes), suite);
        const signatureKey = new material_management_1.SignatureKey(privateKey, compressPoint, suite);
        return new material_management_1.WebCryptoEncryptionMaterial(suite, {
            ...encryptionContext,
            [serialize_1.ENCODED_SIGNER_KEY]: (0, util_base64_browser_1.toBase64)(compressPoint),
        }).setSignatureKey(signatureKey);
    }
    async _initializeDecryptionMaterial(suite, encryptionContext) {
        const { signatureCurve: namedCurve } = suite;
        /* Check for early return (Postcondition): The WebCryptoAlgorithmSuite specification must support a signatureCurve to extract a verification key. */
        if (!namedCurve) {
            /* Precondition: The context must not contain a public key for a non-signing algorithm suite. */
            (0, material_management_1.needs)(!Object.prototype.hasOwnProperty.call(encryptionContext, serialize_1.ENCODED_SIGNER_KEY), 'Encryption context contains public verification key for unsigned algorithm suite.');
            return new material_management_1.WebCryptoDecryptionMaterial(suite, encryptionContext);
        }
        /* Precondition: WebCryptoDefaultCryptographicMaterialsManager If the algorithm suite specification requires a signatureCurve a context must exist. */
        if (!encryptionContext)
            throw new Error('Encryption context does not contain required public key.');
        const { [serialize_1.ENCODED_SIGNER_KEY]: compressPoint } = encryptionContext;
        /* Precondition: WebCryptoDefaultCryptographicMaterialsManager The context must contain the public key. */
        (0, material_management_1.needs)(compressPoint, 'Context does not contain required public key.');
        const backend = await (0, web_crypto_backend_1.getWebCryptoBackend)();
        const subtle = (0, web_crypto_backend_1.getNonZeroByteBackend)(backend);
        const webCryptoAlgorithm = { name: 'ECDSA', namedCurve };
        const extractable = false;
        const usages = ['verify'];
        const format = 'raw';
        const publicKeyBytes = material_management_1.VerificationKey.decodeCompressPoint((0, util_base64_browser_1.fromBase64)(compressPoint), suite);
        const publicKey = await subtle.importKey(format, publicKeyBytes, webCryptoAlgorithm, extractable, usages);
        return new material_management_1.WebCryptoDecryptionMaterial(suite, encryptionContext).setVerificationKey(new material_management_1.VerificationKey(publicKey, suite));
    }
}
exports.WebCryptoDefaultCryptographicMaterialsManager = WebCryptoDefaultCryptographicMaterialsManager;
(0, material_management_1.immutableBaseClass)(WebCryptoDefaultCryptographicMaterialsManager);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJvd3Nlcl9jcnlwdG9ncmFwaGljX21hdGVyaWFsc19tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2Jyb3dzZXJfY3J5cHRvZ3JhcGhpY19tYXRlcmlhbHNfbWFuYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsb0VBQW9FO0FBQ3BFLHNDQUFzQzs7O0FBRXRDLHlFQW1Cd0M7QUFFeEMscURBQTBEO0FBQzFELHVFQUd1QztBQUN2QyxzRUFBbUU7QUFXbkU7Ozs7R0FJRztBQUNILE1BQWEsNkNBQTZDO0lBSXhELFlBQVksT0FBeUI7UUFDbkMsd0RBQXdEO1FBQ3hELElBQUEsMkJBQUssRUFBQyxPQUFPLFlBQVksc0NBQWdCLEVBQUUsbUJBQW1CLENBQUMsQ0FBQTtRQUMvRCxJQUFBLHNDQUFnQixFQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUE7SUFDNUMsQ0FBQztJQUNELEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxFQUMzQixLQUFLLEVBQ0wsaUJBQWlCLEVBQ2pCLGdCQUFnQixHQUNXO1FBQzNCLEtBQUs7WUFDSCxLQUFLO2dCQUNMLElBQUksNkNBQXVCLENBQ3pCLDRDQUFzQixDQUFDLGdCQUFnQixDQUFDLENBQUMscUJBQXFCLENBQy9ELENBQUE7UUFFSDs7Ozs7V0FLRztRQUNILElBQUEsMkJBQUssRUFDSCxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FDbkMsaUJBQWlCLEVBQ2pCLDhCQUFrQixDQUNuQixFQUNELG9DQUFvQyw4QkFBa0IsZUFBZSxDQUN0RSxDQUFBO1FBRUQsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FDM0MsTUFBTSxJQUFJLENBQUMsNkJBQTZCLENBQUMsS0FBSyxFQUFFLGlCQUFpQixDQUFDLENBQ25FLENBQUE7UUFFRDs7OztXQUlHO1FBQ0gsSUFBQSwyQkFBSyxFQUFDLFFB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