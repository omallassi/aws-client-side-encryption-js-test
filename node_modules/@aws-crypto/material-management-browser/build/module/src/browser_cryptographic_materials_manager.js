// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { WebCryptoAlgorithmSuite, WebCryptoEncryptionMaterial, WebCryptoDecryptionMaterial, SignatureKey, needs, readOnlyProperty, VerificationKey, immutableBaseClass, KeyringWebCrypto, CommitmentPolicySuites, } from '@aws-crypto/material-management';
import { ENCODED_SIGNER_KEY } from '@aws-crypto/serialize';
import { getWebCryptoBackend, getNonZeroByteBackend, } from '@aws-crypto/web-crypto-backend';
import { fromBase64, toBase64 } from '@aws-sdk/util-base64-browser';
/**
 * The WebCryptoDefaultCryptographicMaterialsManager is a specific implementation of the CryptographicMaterialsManager.
 * New cryptography materials managers SHOULD extend from WebCryptoMaterialsManager.
 * Users should never need to create an instance of a WebCryptoDefaultCryptographicMaterialsManager.
 */
export class WebCryptoDefaultCryptographicMaterialsManager {
    constructor(keyring) {
        /* Precondition: keyrings must be a KeyringWebCrypto. */
        needs(keyring instanceof KeyringWebCrypto, 'Unsupported type.');
        readOnlyProperty(this, 'keyring', keyring);
    }
    async getEncryptionMaterials({ suite, encryptionContext, commitmentPolicy, }) {
        suite =
            suite ||
                new WebCryptoAlgorithmSuite(CommitmentPolicySuites[commitmentPolicy].defaultAlgorithmSuite);
        /* Precondition: WebCryptoDefaultCryptographicMaterialsManager must reserve the ENCODED_SIGNER_KEY constant from @aws-crypto/serialize.
         * A CryptographicMaterialsManager can change entries to the encryptionContext
         * but changing these values has consequences.
         * The DefaultCryptographicMaterialsManager uses the value in the encryption context to store public signing key.
         * If the caller is using this value in their encryption context the Default CMM is probably not the CMM they want to use.
         */
        needs(!Object.prototype.hasOwnProperty.call(encryptionContext, ENCODED_SIGNER_KEY), `Reserved encryptionContext value ${ENCODED_SIGNER_KEY} not allowed.`);
        const material = await this.keyring.onEncrypt(await this._initializeEncryptionMaterial(suite, encryptionContext));
        /* Postcondition: The WebCryptoEncryptionMaterial must contain a valid dataKey.
         * This verifies that the data key matches the algorithm suite specification
         * and that the unencrypted data key is non-NULL.
         * See: cryptographic_materials.ts, `getUnencryptedDataKey`
         */
        needs(material.hasValidKey(), 'Unencrypted data key is invalid.');
        /* Postcondition: The WebCryptoEncryptionMaterial must contain at least 1 EncryptedDataKey. */
        needs(material.encryptedDataKeys.length, 'No EncryptedDataKeys: the ciphertext can never be decrypted.');
        return material;
    }
    async decryptMaterials({ suite, encryptedDataKeys, encryptionContext, }) {
        const material = await this.keyring.onDecrypt(await this._initializeDecryptionMaterial(suite, encryptionContext), encryptedDataKeys.slice());
        /* Postcondition: The WebCryptoDecryptionMaterial must contain a valid dataKey.
         * See: cryptographic_materials.ts, `getUnencryptedDataKey` also verifies
         * that the unencrypted data key has not been manipulated,
         * that the data key matches the algorithm suite specification
         * and that the unencrypted data key is non-NULL.
         */
        needs(material.hasValidKey(), 'Unencrypted data key is invalid.');
        return material;
    }
    async _initializeEncryptionMaterial(suite, encryptionContext) {
        const { signatureCurve: namedCurve } = suite;
        /* Check for early return (Postcondition): The WebCryptoAlgorithmSuite specification must support a signatureCurve to generate a signing key. */
        if (!namedCurve)
            return new WebCryptoEncryptionMaterial(suite, encryptionContext);
        const backend = await getWebCryptoBackend();
        const subtle = getNonZeroByteBackend(backend);
        const webCryptoAlgorithm = { name: 'ECDSA', namedCurve };
        const extractable = false;
        const usages = ['sign'];
        const format = 'raw';
        const { publicKey, privateKey } = (await subtle.generateKey(webCryptoAlgorithm, extractable, usages));
        const publicKeyBytes = await subtle.exportKey(format, publicKey);
        const compressPoint = SignatureKey.encodeCompressPoint(new Uint8Array(publicKeyBytes), suite);
        const signatureKey = new SignatureKey(privateKey, compressPoint, suite);
        return new WebCryptoEncryptionMaterial(suite, {
            ...encryptionContext,
            [ENCODED_SIGNER_KEY]: toBase64(compressPoint),
        }).setSignatureKey(signatureKey);
    }
    async _initializeDecryptionMaterial(suite, encryptionContext) {
        const { signatureCurve: namedCurve } = suite;
        /* Check for early return (Postcondition): The WebCryptoAlgorithmSuite specification must support a signatureCurve to extract a verification key. */
        if (!namedCurve) {
            /* Precondition: The context must not contain a public key for a non-signing algorithm suite. */
            needs(!Object.prototype.hasOwnProperty.call(encryptionContext, ENCODED_SIGNER_KEY), 'Encryption context contains public verification key for unsigned algorithm suite.');
            return new WebCryptoDecryptionMaterial(suite, encryptionContext);
        }
        /* Precondition: WebCryptoDefaultCryptographicMaterialsManager If the algorithm suite specification requires a signatureCurve a context must exist. */
        if (!encryptionContext)
            throw new Error('Encryption context does not contain required public key.');
        const { [ENCODED_SIGNER_KEY]: compressPoint } = encryptionContext;
        /* Precondition: WebCryptoDefaultCryptographicMaterialsManager The context must contain the public key. */
        needs(compressPoint, 'Context does not contain required public key.');
        const backend = await getWebCryptoBackend();
        const subtle = getNonZeroByteBackend(backend);
        const webCryptoAlgorithm = { name: 'ECDSA', namedCurve };
        const extractable = false;
        const usages = ['verify'];
        const format = 'raw';
        const publicKeyBytes = VerificationKey.decodeCompressPoint(fromBase64(compressPoint), suite);
        const publicKey = await subtle.importKey(format, publicKeyBytes, webCryptoAlgorithm, extractable, usages);
        return new WebCryptoDecryptionMaterial(suite, encryptionContext).setVerificationKey(new VerificationKey(publicKey, suite));
    }
}
immutableBaseClass(WebCryptoDefaultCryptographicMaterialsManager);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJvd3Nlcl9jcnlwdG9ncmFwaGljX21hdGVyaWFsc19tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2Jyb3dzZXJfY3J5cHRvZ3JhcGhpY19tYXRlcmlhbHNfbWFuYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxvRUFBb0U7QUFDcEUsc0NBQXNDO0FBRXRDLE9BQU8sRUFLTCx1QkFBdUIsRUFDdkIsMkJBQTJCLEVBQzNCLDJCQUEyQixFQUMzQixZQUFZLEVBQ1osS0FBSyxFQUNMLGdCQUFnQixFQUNoQixlQUFlLEVBQ2Ysa0JBQWtCLEVBQ2xCLGdCQUFnQixFQUtoQixzQkFBc0IsR0FDdkIsTUFBTSxpQ0FBaUMsQ0FBQTtBQUV4QyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQTtBQUMxRCxPQUFPLEVBQ0wsbUJBQW1CLEVBQ25CLHFCQUFxQixHQUN0QixNQUFNLGdDQUFnQyxDQUFBO0FBQ3ZDLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sOEJBQThCLENBQUE7QUFXbkU7Ozs7R0FJRztBQUNILE1BQU0sT0FBTyw2Q0FBNkM7SUFJeEQsWUFBWSxPQUF5QjtRQUNuQyx3REFBd0Q7UUFDeEQsS0FBSyxDQUFDLE9BQU8sWUFBWSxnQkFBZ0IsRUFBRSxtQkFBbUIsQ0FBQyxDQUFBO1FBQy9ELGdCQUFnQixDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUE7SUFDNUMsQ0FBQztJQUNELEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxFQUMzQixLQUFLLEVBQ0wsaUJBQWlCLEVBQ2pCLGdCQUFnQixHQUNXO1FBQzNCLEtBQUs7WUFDSCxLQUFLO2dCQUNMLElBQUksdUJBQXVCLENBQ3pCLHNCQUFzQixDQUFDLGdCQUFnQixDQUFDLENBQUMscUJBQXFCLENBQy9ELENBQUE7UUFFSDs7Ozs7V0FLRztRQUNILEtBQUssQ0FDSCxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FDbkMsaUJBQWlCLEVBQ2pCLGtCQUFrQixDQUNuQixFQUNELG9DQUFvQyxrQkFBa0IsZUFBZSxDQUN0RSxDQUFBO1FBRUQsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FDM0MsTUFBTSxJQUFJLENBQUMsNkJBQTZCLENBQUMsS0FBSyxFQUFFLGlCQUFpQixDQUFDLENBQ25FLENBQUE7UUFFRDs7OztXQUlHO1FBQ0gsS0FBSyxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsRUFBRSxrQ0FBa0MsQ0FBQyxDQUFBO1FBRWpFLDhGQUE4RjtRQUM5RixLQUFLLENBQ0gsUUFBUSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sRUFDakMsOERBQThELENBQy9ELENBQUE7UUFFRCxPQUFPLFFBQVEsQ0FBQTtJQUNqQixDQUFDO0lBRUQsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEVBQ3JCLEtBQUssRUFDTCxpQkFBaUIsRUFDakIsaUJBQWlCLEdBQ1U7UUFDM0IsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FDM0MsTUFBTSxJQUFJLENBQUMsNkJBQTZCLENBQUMsS0FBSyxFQUFFLGlCQUFpQixDQUFDLEVBQ2xFLGlCQUFpQixDQUFDLEtBQUssRUFBRSxDQUMxQixDQUFBO1FBRUQ7Ozs7O1dBS0c7UUFDSCxLQUFLLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxFQUFFLGtDQUFrQyxDQUFDLENBQUE7UUFFakUsT0FBTyxRQUFRLENBQUE7SUFDakIsQ0FBQztJQUVELEtBQUssQ0FBQyw2QkFBNkIsQ0FDakMsS0FBOEIsRUFDOUIsaUJBQW9DO1FBRXBDLE1BQU0sRUFBRSxjQUFjLEVBQUUsVUFBVSxFQUFFLEdBQUcsS0FBSyxDQUFBO1FBRTVDLGdKQUFnSjtRQUNoSixJQUFJLENBQUMsVUFBVTtZQUNiLE9BQU8sSUFBSSwyQkFBMkIsQ0FBQyxLQUFLLEVBQUUsaUJBQWlCLENBQUMsQ0FBQTtRQUVsRSxNQUFNLE9BQU8sR0FBRyxNQUFNLG1CQUFtQixFQUFFLENBQUE7UUFDM0MsTUFBTSxNQUFNLEdBQUcscUJBQXFCLENBQUMsT0FBTyxDQUFDLENBQUE7UUFFN0MsTUFBTSxrQkFBa0IsR0FBRyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLENBQUE7UUFDeEQsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFBO1FBQ3pCLE1BQU0sTUFBTSxHQUFHLENBQUMsTUFBTSxDQUF3QixDQUFBO1FBQzlDLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQTtRQUVwQixNQUFNLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxHQUFHLENBQUMsTUFBTSxNQUFNLENBQUMsV0FBVyxDQUN6RCxrQkFBa0IsRUFDbEIsV0FBVyxFQUNYLE1BQU0sQ0FDUCxDQUEyQixDQUFBO1FBRTVCLE1BQU0sY0FBYyxHQUFHLE1BQU0sTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUE7UUFDaEUsTUFBTSxhQUFhLEdBQUcsWUFBWSxDQUFDLG1CQUFtQixDQUNwRCxJQUFJLFVBQVUsQ0FBQyxjQUFjLENBQUMsRUFDOUIsS0FBSyxDQUNOLENBQUE7UUFDRCxNQUFNLFlBQVksR0FBRyxJQUFJLFlBQVksQ0FBQyxVQUFVLEVBQUUsYUFBYSxFQUFFLEtBQUssQ0FBQyxDQUFBO1FBQ3ZFLE9BQU8sSUFBSSwyQkFBMkIsQ0FBQyxLQUFLLEVBQUU7WUFDNUMsR0FBRyxpQkFBaUI7WUFDcEIsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxhQUFhLENBQUM7U0FDOUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxZQUFZLENBQUMsQ0FBQTtJQUNsQyxDQUFDO0lBRUQsS0FBSyxDQUFDLDZCQUE2QixDQUNqQyxLQUE4QixFQUM5QixpQkFBb0M7UUFFcEMsTUFBTSxFQUFFLGNBQWMsRUFBRSxVQUFVLEVBQUUsR0FBRyxLQUFLLENBQUE7UUFFNUMsb0pBQW9KO1FBQ3BKLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDZixnR0FBZ0c7WUFDaEcsS0FBSyxDQUNILENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUNuQyxpQkFBaUIsRUFDakIsa0JBQWtCLENBQ25CLEVBQ0QsbUZBQW1GLENBQ3BGLENBQUE7WUFFRCxPQUFPLElBQUksMkJBQTJCLENBQUMsS0FBSyxFQUFFLGlCQUFpQixDQUFDLENBQUE7U0FDakU7UUFFRCxzSkFBc0o7UUFDdEosSUFBSSxDQUFDLGlCQUFpQjtZQUNwQixNQUFNLElBQUksS0FBSyxDQUNiLDBEQUEwRCxDQUMzRCxDQUFBO1FBRUgsTUFBTSxFQUFFLENBQUMsa0JBQWtCLENBQUMsRUFBRSxhQUFhLEVBQUUsR0FBRyxpQkFBaUIsQ0FBQTtRQUVqRSwwR0FBMEc7UUFDMUcsS0FBSyxDQUFDLGFBQWEsRUFBRSwrQ0FBK0MsQ0FBQyxDQUFBO1FBRXJFLE1BQU0sT0FBTyxHQUFHLE1BQU0sbUJBQW1CLEVBQUUsQ0FBQTtRQUMzQyxNQUFNLE1BQU0sR0FBRyxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsQ0FBQTtRQUM3QyxNQUFNLGtCQUFrQixHQUFHLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsQ0FBQTtRQUN4RCxNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUE7UUFDekIsTUFBTSxNQUFNLEdBQUcsQ0FBQyxRQUFRLENBQXdCLENBQUE7UUFDaEQsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFBO1FBRXBCLE1BQU0sY0FBYyxHQUFHLGVBQWUsQ0FBQyxtQkFBbUIsQ0FDeEQsVUFBVSxDQUFDLGFBQWEsQ0FBQyxFQUN6QixLQUFLLENBQ04sQ0FBQTtRQUNELE1BQU0sU0FBUyxHQUFHLE1BQU0sTUFBTSxDQUFDLFNBQVMsQ0FDdEMsTUFBTSxFQUNOLGNBQWMsRUFDZCxrQkFBa0IsRUFDbEIsV0FBVyxFQUNYLE1BQU0sQ0FDUCxDQUFBO1FBRUQsT0FBTyxJQUFJLDJCQUEyQixDQUNwQyxLQUFLLEVBQ0wsaUJBQWlCLENBQ2xCLENBQUMsa0JBQWtCLENBQUMsSUFBSSxlQUFlLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUE7SUFDN0QsQ0FBQztDQUNGO0FBRUQsa0JBQWtCLENBQUMsNkNBQTZDLENBQUMsQ0FBQSJ9