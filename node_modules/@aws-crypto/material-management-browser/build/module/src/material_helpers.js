// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { needs, WebCryptoDecryptionMaterial, isCryptoKey, isValidCryptoKey, keyUsageForMaterial, unwrapDataKey, } from '@aws-crypto/material-management';
import { kdfInfo, kdfCommitKeyInfo, MessageIdLength, } from '@aws-crypto/serialize';
import { getWebCryptoBackend, getNonZeroByteBackend, getZeroByteSubtle, isFullSupportWebCryptoBackend, } from '@aws-crypto/web-crypto-backend';
import { bytes2JWK } from './bytes2_jwk';
export const getEncryptHelper = async (material) => {
    const backend = await getWebCryptoBackend();
    /* Precondition: WebCryptoEncryptionMaterial must have a valid data key. */
    needs(material.hasValidKey(), 'Material has no CryptoKey.');
    const { signatureHash } = material.suite;
    const getEncryptInfo = currySubtleFunction(material, backend, 'encrypt');
    return Object.freeze({
        getEncryptInfo,
        subtleSign: signatureHash ? getSubtleSign : undefined,
        dispose,
    });
    async function getSubtleSign(data) {
        if (!signatureHash)
            throw new Error('Algorithm suite does not support signing.');
        const { signatureKey } = material;
        if (!signatureKey)
            throw new Error('Malformed Material.');
        const { privateKey } = signatureKey;
        if (!isCryptoKey(privateKey))
            throw new Error('Malformed Material.');
        const algorithm = { name: 'ECDSA', hash: { name: signatureHash } };
        return getNonZeroByteBackend(backend).sign(algorithm, privateKey, data);
    }
    function dispose() {
        material.zeroUnencryptedDataKey();
    }
};
export const getDecryptionHelper = async (material) => {
    const backend = await getWebCryptoBackend();
    /* Precondition: WebCryptoDecryptionMaterial must have a valid data key. */
    needs(material.hasValidKey(), 'Material has no valid data key.');
    const { signatureHash } = material.suite;
    const getDecryptInfo = currySubtleFunction(material, backend, 'decrypt');
    return Object.freeze({
        getDecryptInfo,
        subtleVerify: signatureHash ? subtleVerify : undefined,
        dispose,
    });
    async function subtleVerify(signature, data) {
        if (!signatureHash)
            throw new Error('Algorithm suite does not support signing.');
        const { verificationKey } = material;
        if (!verificationKey)
            throw new Error('Malformed Material.');
        const { publicKey } = verificationKey;
        if (!isCryptoKey(publicKey))
            throw new Error('Malformed Material.');
        const algorithm = { name: 'ECDSA', hash: { name: signatureHash } };
        return getNonZeroByteBackend(backend).verify(algorithm, publicKey, signature, data);
    }
    function dispose() {
        material.zeroUnencryptedDataKey();
    }
};
export function currySubtleFunction(material, backend, subtleFunctionName) {
    /* Precondition: The material must have a CryptoKey. */
    needs(material.hasCryptoKey, 'Material must have a CryptoKey.');
    const cryptoKey = material.getCryptoKey();
    /* Precondition: The cryptoKey and backend must match in terms of Mixed vs Full support. */
    needs(isCryptoKey(cryptoKey) === isFullSupportWebCryptoBackend(backend), 'CryptoKey vs WebCrypto backend mismatch.');
    const { suite } = material;
    const { encryption: cipherName, ivLength, tagLength } = suite;
    return async (messageId, commitKey) => {
        /* This is very strange.
         * I would expect that I could await
         * the ternary and all would be fine.
         * But in testing, wallaby.js+webpack
         * compiles the typescript in such a way
         * that `deriveKey` is still
         * a promise by the time it gets to
         * the `data` below.
         * So I add awaits on the individual elements.
         */
        const { deriveKey, keyCommitment } = isCryptoKey(cryptoKey)
            ? await WebCryptoKdf(getNonZeroByteBackend(backend), material, cryptoKey, [subtleFunctionName], messageId, commitKey)
            : await Promise.all([
                WebCryptoKdf(getNonZeroByteBackend(backend), material, cryptoKey.nonZeroByteCryptoKey, [subtleFunctionName], messageId, commitKey),
                WebCryptoKdf(getZeroByteSubtle(backend), material, cryptoKey.zeroByteCryptoKey, [subtleFunctionName], messageId, commitKey),
            ]).then(([nonZeroByteCryptoKey, zeroByteCryptoKey]) => ({
                deriveKey: {
                    nonZeroByteCryptoKey: nonZeroByteCryptoKey.deriveKey,
                    zeroByteCryptoKey: zeroByteCryptoKey.deriveKey,
                },
                /* This works *because* the commitKey
                 * that is passed to both zero and nonzero is the same.
                 * If that ever changed, this might no longer be true.
                 */
                keyCommitment: nonZeroByteCryptoKey.keyCommitment,
            }));
        return (subtleFunctionName === 'encrypt'
            ? { getSubtleEncrypt: getSubtleFunction, keyCommitment }
            : getSubtleFunction);
        function getSubtleFunction(iv, additionalData) {
            /* Precondition: The length of the IV must match the WebCryptoAlgorithmSuite specification. */
            needs(iv.byteLength === ivLength, 'Iv length does not match algorithm suite specification');
            return async (data) => {
                if (isCryptoKey(deriveKey) && isFullSupportWebCryptoBackend(backend)) {
                    const { subtle } = backend;
                    const algorithm = { name: cipherName, iv, additionalData, tagLength };
                    return subtle[subtleFunctionName](algorithm, deriveKey, data);
                }
                else if (!isCryptoKey(deriveKey) &&
                    !isFullSupportWebCryptoBackend(backend)) {
                    const { nonZeroByteSubtle, zeroByteSubtle } = backend;
                    const { nonZeroByteCryptoKey, zeroByteCryptoKey } = deriveKey;
                    const algorithm = { name: cipherName, iv, additionalData, tagLength };
                    /* Precondition: The WebCrypto AES-GCM decrypt API expects the data *and* tag together.
                     * This means that on decrypt any amount of data less than tagLength is invalid.
                     * This also means that zero encrypted data will be equal to tagLength.
                     */
                    const dataByteLength = subtleFunctionName === 'decrypt'
                        ? data.byteLength - tagLength / 8
                        : data.byteLength;
                    needs(dataByteLength >= 0, 'Invalid data length.');
                    if (dataByteLength === 0) {
                        return zeroByteSubtle[subtleFunctionName](algorithm, zeroByteCryptoKey, data);
                    }
                    else {
                        return nonZeroByteSubtle[subtleFunctionName](algorithm, nonZeroByteCryptoKey, data);
                    }
                }
                // This should be impossible
                throw new Error('Unknown Error');
            };
        }
    };
}
export async function WebCryptoKdf(subtle, material, cryptoKey, keyUsages, nonce, commitKey) {
    const { kdf, kdfHash, keyLength, encryption } = material.suite;
    /* Check for early return (Postcondition): No WebCrypto KDF, just return the unencrypted data key. */
    if (!kdf && !kdfHash)
        return { deriveKey: cryptoKey };
    const keyCommitment = await deriveKeyCommitment(subtle, material, cryptoKey, nonce, commitKey);
    // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams
    const kdfAlgorithm = buildAlgorithmForKDF(material.suite, nonce);
    const derivedKeyAlgorithm = { name: encryption, length: keyLength };
    const extractable = false;
    const deriveKey = await subtle.deriveKey(
    // types need to be updated see: https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams
    kdfAlgorithm, cryptoKey, derivedKeyAlgorithm, extractable, keyUsages);
    /* Postcondition: The derived key must conform to the algorith suite specification. */
    needs(isValidCryptoKey(deriveKey, material), 'Invalid derived key');
    return { deriveKey, keyCommitment };
}
export function buildAlgorithmForKDF(suite, nonce) {
    const { kdf, kdfHash, commitmentLength, saltLengthBytes } = suite;
    /* Precondition: Valid HKDF values must exist for browsers. */
    needs(kdf === 'HKDF' && kdfHash && nonce instanceof Uint8Array, 'Invalid HKDF values.');
    if (suite.commitment === 'NONE') {
        /* Precondition: The message ID length must match the specification. */
        needs(nonce.byteLength === MessageIdLength.V1, 'Message id length does not match specification.');
        const info = kdfInfo(suite.id, nonce);
        // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams
        return {
            name: kdf,
            hash: { name: kdfHash },
            info,
            salt: new Uint8Array(),
        };
    }
    /* Precondition UNTESTED: The suite must be well structured. */
    needs(suite.commitment === 'KEY' && commitmentLength && saltLengthBytes, 'Malformed suite data.');
    /* Precondition: The message id length must match the algorithm suite.
     * I am using the message id here,
     * but I must have enough entropy!
     */
    needs(nonce.byteLength === saltLengthBytes, 'Message id length does not match specification.');
    const { keyLabel: info } = kdfCommitKeyInfo(suite);
    const salt = nonce;
    // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams
    return {
        name: kdf,
        hash: { name: kdfHash },
        info,
        salt,
    };
}
export async function deriveKeyCommitment(subtle, material, cryptoKey, nonce, commitKey) {
    const { suite } = material;
    const { kdf, kdfHash, commitmentLength, saltLengthBytes, commitment } = suite;
    /* Check for early return (Postcondition): Algorithm suites without commitment do not have a commitment. */
    if (commitment === 'NONE') {
        /* Postcondition: Non-committing WebCrypto algorithm suites *must* not have a commitment. */
        needs(!commitKey, 'Commitment not supported.');
        return;
    }
    /* Precondition UNTESTED: Only support key commitment. */
    needs(commitment === 'KEY' && commitmentLength && saltLengthBytes, 'Malformed suite data.');
    /* Precondition: Commit key requires 256 bits of entropy. */
    needs(nonce.byteLength === saltLengthBytes, 'Nonce is not the correct length for committed algorithm suite.');
    /* Precondition UNTESTED: Valid HKDF values must exist for commit key. */
    needs(kdf === 'HKDF' && kdfHash && nonce instanceof Uint8Array, 'Invalid HKDF values.');
    const { commitLabel: info } = kdfCommitKeyInfo(material.suite);
    /* In a more perfect world,
     * I would use `deriveBits`.
     * However I _know_ that deriveKey exists,
     * and is already used everywhere.
     * This is ugly here,
     * but is less churn to write today.
     * Also, deriveKey is slightly safer
     * for the actual key used.
     * Since both the commit key
     * and the kdf key come from the same root,
     * I *must* give this permission
     * to this root key.
     * This means that if the root key has `deriveBits`,
     * then I have effectively given `export`
     * to the operational derived key.
     * Because while the root key can not be exported,
     * the derived key could.
     * This is a thin reason, because you could just
     * create your own exportable key,
     * but, every little bit helps.
     */
    const keyCommitAlgorithm = {
        name: kdf,
        hash: { name: kdfHash },
        info,
        salt: nonce,
    };
    const derivedKeyAlgorithm = {
        name: suite.encryption,
        length: commitmentLength,
    };
    const extractable = true;
    const deriveKey = await subtle.deriveKey(
    // types need to be updated see: https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams
    keyCommitAlgorithm, cryptoKey, derivedKeyAlgorithm, extractable, 
    /* Something has to go here. */
    ['encrypt']);
    const keyCommitment = new Uint8Array(await subtle.exportKey('raw', deriveKey));
    const isDecrypt = material instanceof WebCryptoDecryptionMaterial;
    /* Precondition: If material is WebCryptoDecryptionMaterial the key commitments *must* match.
     * Ideally this will be checked _before_ the data key is derived
     * because then the decryption key is never even derived.
     * But for WebCrypto this is a bit hard,
     * because of legacy browsers and the lack of zero byte support.
     */
    needs((isDecrypt &&
        commitKey &&
        portableTimingSafeEqual(commitKey, keyCommitment)) ||
        (!isDecrypt && !commitKey), isDecrypt ? 'Commitment does not match.' : 'Invalid arguments.');
    return keyCommitment;
}
export async function importCryptoKey(backend, material, keyUsages = [keyUsageForMaterial(material)]) {
    if (isFullSupportWebCryptoBackend(backend)) {
        return _importCryptoKey(backend.subtle, material, keyUsages);
    }
    else {
        return Promise.all([
            _importCryptoKey(getNonZeroByteBackend(backend), material, keyUsages),
            _importCryptoKey(getZeroByteSubtle(backend), material, keyUsages),
        ]).then(([nonZeroByteCryptoKey, zeroByteCryptoKey]) => ({
            nonZeroByteCryptoKey,
            zeroByteCryptoKey,
        }));
    }
}
export async function _importCryptoKey(subtle, material, keyUsages = [keyUsageForMaterial(material)]) {
    const { suite } = material;
    const extractable = false;
    const udk = unwrapDataKey(material.getUnencryptedDataKey());
    if (suite.kdf) {
        /* For several browsers, import for a key to derive with HKDF
         * *must* be raw.  This may cause some compatibility issues
         * with browsers that need a zero byte gcm fallback.
         */
        const format = 'raw';
        const algorithm = { name: suite.kdf, length: suite.keyLength };
        return subtle.importKey(format, udk, algorithm, extractable, keyUsages);
    }
    else {
        const format = 'jwk';
        const algorithm = { name: suite.encryption, length: suite.keyLength };
        const jwk = bytes2JWK(udk);
        return subtle.importKey(format, jwk, algorithm, extractable, keyUsages);
    }
}
function portableTimingSafeEqual(a, b) {
    /* It is *possible* that a runtime could optimize this constant time function.
     * Adding `eval` could prevent the optimization, but this is no guarantee.
     * The eval below is commented out
     * because if a browser is using a Content Security Policy with `'unsafe-eval'`
     * it would fail on this eval.
     * The value in attempting to ensure that this function is not optimized
     * is not worth the cost of making customers allow `'unsafe-eval'`.
     * If you want to copy this function for your own use,
     * please review the timing-attack link above.
     * Side channel attacks are pernicious and subtle.
     */
    // eval('') // eslint-disable-line no-eval
    /* Check for early return (Postcondition) UNTESTED: Size is well-know information
     * and does not leak information about contents.
     */
    if (a.byteLength !== b.byteLength)
        return false;
    let diff = 0;
    for (let i = 0; i < b.length; i++) {
        diff |= a[i] ^ b[i];
    }
    return diff === 0;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0ZXJpYWxfaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9tYXRlcmlhbF9oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG9FQUFvRTtBQUNwRSxzQ0FBc0M7QUFFdEMsT0FBTyxFQUNMLEtBQUssRUFFTCwyQkFBMkIsRUFDM0IsV0FBVyxFQUNYLGdCQUFnQixFQUNoQixtQkFBbUIsRUFDbkIsYUFBYSxHQUlkLE1BQU0saUNBQWlDLENBQUE7QUFDeEMsT0FBTyxFQUNMLE9BQU8sRUFDUCxnQkFBZ0IsRUFDaEIsZUFBZSxHQUNoQixNQUFNLHVCQUF1QixDQUFBO0FBRTlCLE9BQU8sRUFDTCxtQkFBbUIsRUFDbkIscUJBQXFCLEVBQ3JCLGlCQUFpQixFQUNqQiw2QkFBNkIsR0FFOUIsTUFBTSxnQ0FBZ0MsQ0FBQTtBQUV2QyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sY0FBYyxDQUFBO0FBaUN4QyxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBcUIsS0FBSyxFQUNyRCxRQUFxQyxFQUNyQyxFQUFFO0lBQ0YsTUFBTSxPQUFPLEdBQUcsTUFBTSxtQkFBbUIsRUFBRSxDQUFBO0lBRTNDLDJFQUEyRTtJQUMzRSxLQUFLLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxFQUFFLDRCQUE0QixDQUFDLENBQUE7SUFFM0QsTUFBTSxFQUFFLGFBQWEsRUFBRSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUE7SUFDeEMsTUFBTSxjQUFjLEdBQUcsbUJBQW1CLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQTtJQUN4RSxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFDbkIsY0FBYztRQUNkLFVBQVUsRUFBRSxhQUFhLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsU0FBUztRQUNyRCxPQUFPO0tBQ1IsQ0FBQyxDQUFBO0lBRUYsS0FBSyxVQUFVLGFBQWEsQ0FBQyxJQUFn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