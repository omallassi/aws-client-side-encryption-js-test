// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { KeyringWebCrypto, needs, EncryptedDataKey, KeyringTraceFlag, immutableClass, readOnlyProperty, bytes2JWK, keyUsageForMaterial, importForWebCryptoEncryptionMaterial, unwrapDataKey, } from '@aws-crypto/material-management-browser';
import { getWebCryptoBackend, getNonZeroByteBackend, isFullSupportWebCryptoBackend, } from '@aws-crypto/web-crypto-backend';
import { _onEncrypt, _onDecrypt, } from '@aws-crypto/raw-keyring';
import { randomValuesOnly } from '@aws-crypto/random-source-browser';
import { getImportOptions, getWrappingAlgorithm, flattenMixedCryptoKey, } from './get_import_options';
// noinspection TypeScriptValidateTypes
export class RawRsaKeyringWebCrypto extends KeyringWebCrypto {
    constructor(input) {
        super();
        const { publicKey, privateKey, keyName, keyNamespace } = input;
        /* Precondition: RsaKeyringWebCrypto needs either a public or a private key to operate. */
        needs(publicKey || privateKey, 'No Key provided.');
        /* Precondition: RsaKeyringWebCrypto needs identifying information for encrypt and decrypt. */
        needs(keyName && keyNamespace, 'Identifying information must be defined.');
        const wrappingAlgorithm = getWrappingAlgorithm(publicKey, privateKey);
        const _wrapKey = async (material) => {
            /* Precondition: I must have a publicKey to wrap. */
            if (!publicKey)
                throw new Error('No publicKey configured, encrypt not supported.');
            // The nonZero backend is used because some browsers support Subtle Crypto
            // but do not support Zero Byte AES-GCM. I want to use the native
            // browser implementation of wrapKey
            const subtle = getNonZeroByteBackend(await getWebCryptoBackend());
            /* Can not use importCryptoKey as `wrapKey` requires extractable = true
             * In web crypto `wrapKey` is a composition of `export` and `encrypt` and
             * so the cryptoKey must have `extractable = true`.
             */
            const extractable = true;
            const { encryption } = material.suite;
            const importFormat = 'jwk';
            const keyUsages = ['wrapKey']; // limit the use of this key (*not* decrypt, encrypt, deriveKey)
            const jwk = bytes2JWK(unwrapDataKey(material.getUnencryptedDataKey()));
            const cryptoKey = await subtle.importKey(importFormat, jwk, encryption, extractable, keyUsages);
            const wrapFormat = 'raw';
            const encryptedArrayBuffer = await subtle.wrapKey(wrapFormat, cryptoKey, publicKey, wrappingAlgorithm);
            // Can the extractable setting of cryptoKey be changed to false here?  If so, do it.
            const edk = new EncryptedDataKey({
                providerId: keyNamespace,
                providerInfo: keyName,
                encryptedDataKey: new Uint8Array(encryptedArrayBuffer),
            });
            return material.addEncryptedDataKey(edk, KeyringTraceFlag.WRAPPING_KEY_ENCRYPTED_DATA_KEY);
        };
        /* returns either an array of 1 CryptoKey or an array of both from MixedBackendCryptoKey e.g.
         * [privateKey] || [nonZeroByteCryptoKey, zeroByteCryptoKey]
         */
        const privateKeys = flattenMixedCryptoKey(privateKey);
        const _unwrapKey = async (material, edk) => {
            /* Precondition: I must have a privateKey to unwrap. */
            if (!privateKey)
                throw new Error('No privateKey configured, decrypt not supported.');
            const backend = await getWebCryptoBackend();
            const { suite } = material;
            const trace = {
                keyName: this.keyName,
                keyNamespace: this.keyNamespace,
                flags: KeyringTraceFlag.WRAPPING_KEY_DECRYPTED_DATA_KEY,
            };
            const format = 'raw';
            const extractable = false;
            const algorithm = suite.kdf ? suite.kdf : suite.encryption;
            const keyUsages = [keyUsageForMaterial(material)];
            const importArgs = [
                format,
                edk.encryptedDataKey,
                privateKeys[0],
                wrappingAlgorithm,
                algorithm,
                extractable,
                keyUsages,
            ];
            /* This is superior to importForWebCryptoDecryptionMaterial.
             * Here I use `subtle.unwrap` and bring the unencrypted data key into the WebCrypto world
             * without ever exposing the unencrypted data key to JavaScript.
             */
            if (isFullSupportWebCryptoBackend(backend)) {
                const cryptoKey = await backend.subtle.unwrapKey(...importArgs);
                return material.setCryptoKey(cryptoKey, trace);
            }
            else {
                const importZeroBackend = [...importArgs];
                importZeroBackend[2] = privateKeys[1];
                const mixedDataKey = await Promise.all([
                    backend.nonZeroByteSubtle.unwrapKey(...importArgs),
                    backend.zeroByteSubtle.unwrapKey(...importZeroBackend),
                ]).then(([nonZeroByteCryptoKey, zeroByteCryptoKey]) => ({
                    nonZeroByteCryptoKey,
                    zeroByteCryptoKey,
                }));
                return material.setCryptoKey(mixedDataKey, trace);
            }
        };
        readOnlyProperty(this, 'keyName', keyName);
        readOnlyProperty(this, 'keyNamespace', keyNamespace);
        readOnlyProperty(this, '_wrapKey', _wrapKey);
        readOnlyProperty(this, '_unwrapKey', _unwrapKey);
    }
    _filter({ providerId, providerInfo }) {
        const { keyNamespace, keyName } = this;
        return providerId === keyNamespace && providerInfo.startsWith(keyName);
    }
    _rawOnEncrypt = _onEncrypt(randomValuesOnly);
    _onEncrypt = async (material) => {
        const _material = await this._rawOnEncrypt(material);
        return importForWebCryptoEncryptionMaterial(_material);
    };
    /* onDecrypt does not need to import the CryptoKey, because this is handled in the unwrap operation.
     * Encrypt needs to have access to the unencrypted data key to encrypt with other keyrings
     * but once I have functional material no other decrypt operations need to be performed.
     */
    _onDecrypt = _onDecrypt();
    static async importPublicKey(publicKey) {
        const op = getImportOptions(publicKey);
        const backend = await getWebCryptoBackend();
        const subtle = getNonZeroByteBackend(backend);
        return ImportKeyTypeOverload(op, subtle, ['wrapKey']);
    }
    static async importPrivateKey(privateKey) {
        const op = getImportOptions(privateKey);
        const backend = await getWebCryptoBackend();
        if (isFullSupportWebCryptoBackend(backend)) {
            return ImportKeyTypeOverload(op, backend.subtle, ['unwrapKey']);
        }
        else {
            return Promise.all([
                ImportKeyTypeOverload(op, backend.nonZeroByteSubtle, ['unwrapKey']),
                ImportKeyTypeOverload(op, backend.zeroByteSubtle, ['unwrapKey']),
            ]).then(([nonZeroByteCryptoKey, zeroByteCryptoKey]) => ({
                nonZeroByteCryptoKey,
                zeroByteCryptoKey,
            }));
        }
    }
}
immutableClass(RawRsaKeyringWebCrypto);
// TS2769 Note:
// TS2769 is "No overload matches this call".
// Above and below, TS is incorrect.
// `importKey` has two overrides,
// They are abbreviated below:
// ```
// importKey(format: "jwk", keyData: JsonWebKey, algorithm: AlgorithmIdentifier | ... , extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKey>;
// importKey(format:  "raw" | "pkcs8" | "spki", keyData: BufferSource, algorithm: AlgorithmIdentifier | ..., extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKey>;
// ```
// The method getImportOptions explicitly
// returns format & key that match
// these overrides.
// However, TS is unable to recognize this easily.
// The following ugly function does the disambiguation.
// There are 2 problems that TS is having.
// First when format key and wrappingAlgorithm are independent,
// TS does not _remember_ the relationship between format and key.
// The second issue is related,
// when trying to select the proper overload,
// it is collapsing the definition of format.
// Thus discriminating the union by `format`
// helps TS understand all the arguments.
async function ImportKeyTypeOverload(op, subtle, keyUsages) {
    return op.format == 'jwk'
        ? subtle.importKey(op.format, op.key, op.wrappingAlgorithm, false, keyUsages)
        : subtle.importKey(op.format, op.key, op.wrappingAlgorithm, false, keyUsages);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmF3X3JzYV9rZXlyaW5nX3dlYl9jcnlwdG8uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcmF3X3JzYV9rZXlyaW5nX3dlYl9jcnlwdG8udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsb0VBQW9FO0FBQ3BFLHNDQUFzQztBQUV0QyxPQUFPLEVBQ0wsZ0JBQWdCLEVBQ2hCLEtBQUssRUFHTCxnQkFBZ0IsRUFFaEIsZ0JBQWdCLEVBQ2hCLGNBQWMsRUFDZCxnQkFBZ0IsRUFDaEIsU0FBUyxFQUNULG1CQUFtQixFQUNuQixvQ0FBb0MsRUFDcEMsYUFBYSxHQUlkLE1BQU0seUNBQXlDLENBQUE7QUFFaEQsT0FBTyxFQUNMLG1CQUFtQixFQUNuQixxQkFBcUIsRUFDckIsNkJBQTZCLEdBQzlCLE1BQU0sZ0NBQWdDLENBQUE7QUFDdkMsT0FBTyxFQUNMLFVBQVUsRUFDVixVQUFVLEdBR1gsTUFBTSx5QkFBeUIsQ0FBQTtBQUNoQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQTtBQUVwRSxPQUFPLEVBQ0wsZ0JBQWdCLEVBQ2hCLG9CQUFvQixFQUNwQixxQkFBcUIsR0FDdEIsTUFBTSxzQkFBc0IsQ0FBQTtBQUU3Qix1Q0FBdUM7QUFDdkMsTUFBTSxPQUFPLHNCQUF1QixTQUFRLGdCQUFnQjtJQU0xRCxZQUFZLEtBQWtDO1FBQzVDLEtBQUssRUFBRSxDQUFBO1FBRVAsTUFBTSxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLFlBQVksRUFBRSxHQUFHLEtBQUssQ0FBQTtRQUM5RCwwRkFBMEY7UUFDMUYsS0FBSyxDQUFDLFNBQVMsSUFBSSxVQUFVLEVBQUUsa0JBQWtCLENBQUMsQ0FBQTtRQUNsRCw4RkFBOEY7UUFDOUYsS0FBSyxDQUFDLE9BQU8sSUFBSSxZQUFZLEVBQUUsMENBQTBDLENBQUMsQ0FBQTtRQUUxRSxNQUFNLGlCQUFpQixHQUFHLG9CQUFvQixDQUFDLFNBQVMsRUFBRSxV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