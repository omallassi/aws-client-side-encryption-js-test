"use strict";
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.RawRsaKeyringWebCrypto = void 0;
const material_management_browser_1 = require("@aws-crypto/material-management-browser");
const web_crypto_backend_1 = require("@aws-crypto/web-crypto-backend");
const raw_keyring_1 = require("@aws-crypto/raw-keyring");
const random_source_browser_1 = require("@aws-crypto/random-source-browser");
const get_import_options_1 = require("./get_import_options");
// noinspection TypeScriptValidateTypes
class RawRsaKeyringWebCrypto extends material_management_browser_1.KeyringWebCrypto {
    constructor(input) {
        super();
        const { publicKey, privateKey, keyName, keyNamespace } = input;
        /* Precondition: RsaKeyringWebCrypto needs either a public or a private key to operate. */
        (0, material_management_browser_1.needs)(publicKey || privateKey, 'No Key provided.');
        /* Precondition: RsaKeyringWebCrypto needs identifying information for encrypt and decrypt. */
        (0, material_management_browser_1.needs)(keyName && keyNamespace, 'Identifying information must be defined.');
        const wrappingAlgorithm = (0, get_import_options_1.getWrappingAlgorithm)(publicKey, privateKey);
        const _wrapKey = async (material) => {
            /* Precondition: I must have a publicKey to wrap. */
            if (!publicKey)
                throw new Error('No publicKey configured, encrypt not supported.');
            // The nonZero backend is used because some browsers support Subtle Crypto
            // but do not support Zero Byte AES-GCM. I want to use the native
            // browser implementation of wrapKey
            const subtle = (0, web_crypto_backend_1.getNonZeroByteBackend)(await (0, web_crypto_backend_1.getWebCryptoBackend)());
            /* Can not use importCryptoKey as `wrapKey` requires extractable = true
             * In web crypto `wrapKey` is a composition of `export` and `encrypt` and
             * so the cryptoKey must have `extractable = true`.
             */
            const extractable = true;
            const { encryption } = material.suite;
            const importFormat = 'jwk';
            const keyUsages = ['wrapKey']; // limit the use of this key (*not* decrypt, encrypt, deriveKey)
            const jwk = (0, material_management_browser_1.bytes2JWK)((0, material_management_browser_1.unwrapDataKey)(material.getUnencryptedDataKey()));
            const cryptoKey = await subtle.importKey(importFormat, jwk, encryption, extractable, keyUsages);
            const wrapFormat = 'raw';
            const encryptedArrayBuffer = await subtle.wrapKey(wrapFormat, cryptoKey, publicKey, wrappingAlgorithm);
            // Can the extractable setting of cryptoKey be changed to false here?  If so, do it.
            const edk = new material_management_browser_1.EncryptedDataKey({
                providerId: keyNamespace,
                providerInfo: keyName,
                encryptedDataKey: new Uint8Array(encryptedArrayBuffer),
            });
            return material.addEncryptedDataKey(edk, material_management_browser_1.KeyringTraceFlag.WRAPPING_KEY_ENCRYPTED_DATA_KEY);
        };
        /* returns either an array of 1 CryptoKey or an array of both from MixedBackendCryptoKey e.g.
         * [privateKey] || [nonZeroByteCryptoKey, zeroByteCryptoKey]
         */
        const privateKeys = (0, get_import_options_1.flattenMixedCryptoKey)(privateKey);
        const _unwrapKey = async (material, edk) => {
            /* Precondition: I must have a privateKey to unwrap. */
            if (!privateKey)
                throw new Error('No privateKey configured, decrypt not supported.');
            const backend = await (0, web_crypto_backend_1.getWebCryptoBackend)();
            const { suite } = material;
            const trace = {
                keyName: this.keyName,
                keyNamespace: this.keyNamespace,
                flags: material_management_browser_1.KeyringTraceFlag.WRAPPING_KEY_DECRYPTED_DATA_KEY,
            };
            const format = 'raw';
            const extractable = false;
            const algorithm = suite.kdf ? suite.kdf : suite.encryption;
            const keyUsages = [(0, material_management_browser_1.keyUsageForMaterial)(material)];
            const importArgs = [
                format,
                edk.encryptedDataKey,
                privateKeys[0],
                wrappingAlgorithm,
                algorithm,
                extractable,
                keyUsages,
            ];
            /* This is superior to importForWebCryptoDecryptionMaterial.
             * Here I use `subtle.unwrap` and bring the unencrypted data key into the WebCrypto world
             * without ever exposing the unencrypted data key to JavaScript.
             */
            if ((0, web_crypto_backend_1.isFullSupportWebCryptoBackend)(backend)) {
                const cryptoKey = await backend.subtle.unwrapKey(...importArgs);
                return material.setCryptoKey(cryptoKey, trace);
            }
            else {
                const importZeroBackend = [...importArgs];
                importZeroBackend[2] = privateKeys[1];
                const mixedDataKey = await Promise.all([
                    backend.nonZeroByteSubtle.unwrapKey(...importArgs),
                    backend.zeroByteSubtle.unwrapKey(...importZeroBackend),
                ]).then(([nonZeroByteCryptoKey, zeroByteCryptoKey]) => ({
                    nonZeroByteCryptoKey,
                    zeroByteCryptoKey,
                }));
                return material.setCryptoKey(mixedDataKey, trace);
            }
        };
        (0, material_management_browser_1.readOnlyProperty)(this, 'keyName', keyName);
        (0, material_management_browser_1.readOnlyProperty)(this, 'keyNamespace', keyNamespace);
        (0, material_management_browser_1.readOnlyProperty)(this, '_wrapKey', _wrapKey);
        (0, material_management_browser_1.readOnlyProperty)(this, '_unwrapKey', _unwrapKey);
    }
    _filter({ providerId, providerInfo }) {
        const { keyNamespace, keyName } = this;
        return providerId === keyNamespace && providerInfo.startsWith(keyName);
    }
    _rawOnEncrypt = (0, raw_keyring_1._onEncrypt)(random_source_browser_1.randomValuesOnly);
    _onEncrypt = async (material) => {
        const _material = await this._rawOnEncrypt(material);
        return (0, material_management_browser_1.importForWebCryptoEncryptionMaterial)(_material);
    };
    /* onDecrypt does not need to import the CryptoKey, because this is handled in the unwrap operation.
     * Encrypt needs to have access to the unencrypted data key to encrypt with other keyrings
     * but once I have functional material no other decrypt operations need to be performed.
     */
    _onDecrypt = (0, raw_keyring_1._onDecrypt)();
    static async importPublicKey(publicKey) {
        const op = (0, get_import_options_1.getImportOptions)(publicKey);
        const backend = await (0, web_crypto_backend_1.getWebCryptoBackend)();
        const subtle = (0, web_crypto_backend_1.getNonZeroByteBackend)(backend);
        return ImportKeyTypeOverload(op, subtle, ['wrapKey']);
    }
    static async importPrivateKey(privateKey) {
        const op = (0, get_import_options_1.getImportOptions)(privateKey);
        const backend = await (0, web_crypto_backend_1.getWebCryptoBackend)();
        if ((0, web_crypto_backend_1.isFullSupportWebCryptoBackend)(backend)) {
            return ImportKeyTypeOverload(op, backend.subtle, ['unwrapKey']);
        }
        else {
            return Promise.all([
                ImportKeyTypeOverload(op, backend.nonZeroByteSubtle, ['unwrapKey']),
                ImportKeyTypeOverload(op, backend.zeroByteSubtle, ['unwrapKey']),
            ]).then(([nonZeroByteCryptoKey, zeroByteCryptoKey]) => ({
                nonZeroByteCryptoKey,
                zeroByteCryptoKey,
            }));
        }
    }
}
exports.RawRsaKeyringWebCrypto = RawRsaKeyringWebCrypto;
(0, material_management_browser_1.immutableClass)(RawRsaKeyringWebCrypto);
// TS2769 Note:
// TS2769 is "No overload matches this call".
// Above and below, TS is incorrect.
// `importKey` has two overrides,
// They are abbreviated below:
// ```
// importKey(format: "jwk", keyData: JsonWebKey, algorithm: AlgorithmIdentifier | ... , extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKey>;
// importKey(format:  "raw" | "pkcs8" | "spki", keyData: BufferSource, algorithm: AlgorithmIdentifier | ..., extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKey>;
// ```
// The method getImportOptions explicitly
// returns format & key that match
// these overrides.
// However, TS is unable to recognize this easily.
// The following ugly function does the disambiguation.
// There are 2 problems that TS is having.
// First when format key and wrappingAlgorithm are independent,
// TS does not _remember_ the relationship between format and key.
// The second issue is related,
// when trying to select the proper overload,
// it is collapsing the definition of format.
// Thus discriminating the union by `format`
// helps TS understand all the arguments.
async function ImportKeyTypeOverload(op, subtle, keyUsages) {
    return op.format == 'jwk'
        ? subtle.importKey(op.format, op.key, op.wrappingAlgorithm, false, keyUsages)
        : subtle.importKey(op.format, op.key, op.wrappingAlgorithm, false, keyUsages);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmF3X3JzYV9rZXlyaW5nX3dlYl9jcnlwdG8uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcmF3X3JzYV9rZXlyaW5nX3dlYl9jcnlwdG8udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLG9FQUFvRTtBQUNwRSxzQ0FBc0M7OztBQUV0Qyx5RkFpQmdEO0FBRWhELHVFQUl1QztBQUN2Qyx5REFLZ0M7QUFDaEMsNkVBQW9FO0FBRXBFLDZEQUk2QjtBQUU3Qix1Q0FBdUM7QUFDdkMsTUFBYSxzQkFBdUIsU0FBUSw4Q0FBZ0I7SUFNMUQsWUFBWSxLQUFrQztRQUM1QyxLQUFLLEVBQUUsQ0FBQTtRQUVQLE1BQU0sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQUUsR0FBRyxLQUFLLENBQUE7UUFDOUQsMEZBQTBGO1FBQzFGLElBQUEsbUNBQUssRUFBQyxTQUFTLElBQUksVUFBVSxFQUFFLGtCQUFrQixDQUFDLENBQUE7UUFDbEQsOEZBQThGO1FBQzlGLElBQUEsbUNBQUssRUFBQyxPQUFPLElBQUksWUFBWSxFQUFFLDBDQUEwQyxDQUFDLENBQUE7UUFFMUUsTUFBTSxpQkFBaUIsR0FBRyxJQUFBLHlDQUFvQixFQUFDLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FBQTtRQUVyRSxNQUFNLFFBQVEsR0FBRyxLQUFLLEVBQUUsUUFBcUMsRUFBRSxFQUFFO1lBQy9ELG9EQUFvRDtZQUNwRCxJQUFJLENBQUMsU0FBUztnQkFDWixNQUFNLElBQUksS0FBSyxDQUFDLGlEQUFpRCxDQUFDLENBQUE7WUFFcEUsMEVBQTBFO1lBQzFFLGlFQUFpRTtZQUNqRSxvQ0FBb0M7WUFDcEMsTUFBTSxNQUFNLEdBQUcsSUFBQSwwQ0FBcUIsRUFBQyxNQUFNLElBQUEsd0NBQW1CLEdBQUUsQ0FBQyxDQUFBO1lBQ2pFOzs7ZUFHRztZQUNILE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQTtZQUN4QixNQUFNLEVBQUUsVUFBVSxF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