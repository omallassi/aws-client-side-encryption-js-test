// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { WebCryptoAlgorithmSuite, KeyringWebCrypto, WebCryptoDefaultCryptographicMaterialsManager, getDecryptionHelper, needs, CommitmentPolicy, CommitmentPolicySuites, } from '@aws-crypto/material-management-browser';
import { deserializeSignature, deserializeFactory, decodeBodyHeader, aadFactory, concatBuffers, der2raw, } from '@aws-crypto/serialize';
import { fromUtf8, toUtf8 } from '@aws-sdk/util-utf8-browser';
const deserialize = deserializeFactory(toUtf8, WebCryptoAlgorithmSuite);
const { messageAADContentString, messageAAD } = aadFactory(fromUtf8);
export async function _decrypt({ commitmentPolicy, maxEncryptedDataKeys }, cmm, ciphertext) {
    /* Precondition: _decrypt needs a valid commitmentPolicy. */
    needs(CommitmentPolicy[commitmentPolicy], 'Invalid commitment policy.');
    // buildDecrypt defaults this to false for backwards compatibility, so this is satisfied
    /* Precondition: _decrypt needs a valid maxEncryptedDataKeys. */
    needs(maxEncryptedDataKeys === false || maxEncryptedDataKeys >= 1, 'Invalid maxEncryptedDataKeys value.');
    /* If the cmm is a Keyring, wrap it with WebCryptoDefaultCryptographicMaterialsManager. */
    cmm =
        cmm instanceof KeyringWebCrypto
            ? new WebCryptoDefaultCryptographicMaterialsManager(cmm)
            : cmm;
    const headerInfo = deserialize.deserializeMessageHeader(ciphertext, {
        maxEncryptedDataKeys,
    });
    if (headerInfo === false)
        throw new Error('Unable to parse Header');
    const { messageHeader, algorithmSuite } = headerInfo;
    const { rawHeader, headerAuth } = headerInfo;
    const { headerIv, headerAuthTag } = headerAuth;
    const { encryptionContext, encryptedDataKeys, suiteId, messageId } = messageHeader;
    // Very quick hex string
    const messageIdStr = [...messageId]
        .map((i) => (i > 15 ? i.toString(16) : '0' + i.toString(16)))
        .join('');
    /* Precondition: The parsed header algorithmSuite in _decrypt must be supported by the commitmentPolicy. */
    CommitmentPolicySuites.isDecryptEnabled(commitmentPolicy, algorithmSuite, messageIdStr);
    const suite = new WebCryptoAlgorithmSuite(suiteId);
    const material = await cmm.decryptMaterials({
        suite,
        encryptionContext,
        encryptedDataKeys,
    });
    /* Precondition: The material algorithmSuite returned to _decrypt must be supported by the commitmentPolicy. */
    CommitmentPolicySuites.isDecryptEnabled(commitmentPolicy, material.suite, messageIdStr);
    const { getDecryptInfo, subtleVerify, dispose } = await getDecryptionHelper(material);
    const getSubtleDecrypt = await getDecryptInfo(messageId, messageHeader.suiteData);
    // The tag is appended to the Data
    await getSubtleDecrypt(headerIv, rawHeader)(headerAuthTag); // will throw if invalid
    const { plaintext, readPos } = await bodyDecrypt({
        buffer: ciphertext,
        getSubtleDecrypt,
        headerInfo,
    });
    dispose();
    if (subtleVerify) {
        const data = ciphertext.slice(0, readPos);
        const signatureInfo = ciphertext.slice(readPos);
        const derSignature = deserializeSignature(signatureInfo);
        const rawSignature = der2raw(derSignature, material.suite);
        const isValid = await subtleVerify(rawSignature, data);
        /* Postcondition: subtleVerify must validate the signature. */
        needs(isValid, 'Invalid Signature');
        return { messageHeader, plaintext };
    }
    else {
        return { messageHeader, plaintext };
    }
}
async function bodyDecrypt({ buffer, getSubtleDecrypt, headerInfo, }) {
    let readPos = headerInfo.rawHeader.byteLength + headerInfo.headerAuth.headerAuthLength;
    const clearBuffers = [];
    let sequenceNumber = 0;
    // This is unfortunate, ideally the eslint no-constant-condition could be resolve
    // but at this time, I'm just going to disable this line
    // and leave a note to keep myself from replicating this kind of logic.
    /* eslint-disable no-constant-condition */
    while (true) {
        /* eslint-enable no-constant-condition */
        /* Keeping track of the sequence number myself. */
        sequenceNumber += 1;
        const { clearBlob, frameInfo } = await framedDecrypt({
            buffer,
            getSubtleDecrypt,
            headerInfo,
            readPos,
        });
        /* Precondition: The sequenceNumber is required to monotonically increase, starting from 1.
         * This is to avoid a bad actor from abusing the sequence number on un-signed algorithm suites.
         * If the frame size matched the data format (say NDJSON),
         * then the data could be significantly altered just by rearranging the frames.
         * Non-framed data returns a sequenceNumber of 1.
         */
        needs(frameInfo.sequenceNumber === sequenceNumber, 'Encrypted body sequence out of order.');
        clearBuffers.push(clearBlob);
        readPos = frameInfo.readPos;
        if (frameInfo.isFinalFrame) {
            const plaintext = concatBuffers(...clearBuffers);
            return { plaintext, readPos };
        }
    }
}
/* As we move to deprecate non-framed encrypt it is important to continue to support
 * non-framed decrypt.  The names not-withstanding, this supports non-framed decrypt
 * See decodeBodyHeader (it abstracts framed and non-framed body headers)
 */
async function framedDecrypt({ buffer, getSubtleDecrypt, headerInfo, readPos, }) {
    const { messageHeader: { messageId }, } = headerInfo;
    const frameInfo = decodeBodyHeader(buffer, headerInfo, readPos);
    if (!frameInfo)
        throw new Error('Format Error');
    const cipherLength = frameInfo.contentLength + frameInfo.tagLength / 8;
    const contentString = messageAADContentString(frameInfo);
    const messageAdditionalData = messageAAD(messageId, contentString, frameInfo.sequenceNumber, frameInfo.contentLength);
    const cipherBlob = buffer.slice(frameInfo.readPos, frameInfo.readPos + cipherLength);
    const clearBlob = await getSubtleDecrypt(frameInfo.iv, messageAdditionalData)(cipherBlob);
    frameInfo.readPos += cipherLength;
    return { clearBlob, frameInfo };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjcnlwdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kZWNyeXB0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG9FQUFvRTtBQUNwRSxzQ0FBc0M7QUFFdEMsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixnQkFBZ0IsRUFDaEIsNkNBQTZDLEVBQzdDLG1CQUFtQixFQUVuQixLQUFLLEVBRUwsZ0JBQWdCLEVBQ2hCLHNCQUFzQixHQUV2QixNQUFNLHlDQUF5QyxDQUFBO0FBQ2hELE9BQU8sRUFDTCxvQkFBb0IsRUFFcEIsa0JBQWtCLEVBQ2xCLGdCQUFnQixFQUNoQixVQUFVLEVBQ1YsYUFBYSxFQUNiLE9BQU8sR0FHUixNQUFNLHVCQUF1QixDQUFBO0FBQzlCLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLE1BQU0sNEJBQTRCLENBQUE7QUFFN0QsTUFBTSxXQUFXLEdBQUcsa0JBQWtCLENBQUMsTUFBTSxFQUFFLHVCQUF1QixDQUFDLENBQUE7QUFDdkUsTUFBTSxFQUFFLHVCQUF1QixFQUFFLFVBQVUsRUFBRSxHQUFHLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQTtBQU9wRSxNQUFNLENBQUMsS0FBSyxVQUFVLFFBQVEsQ0FDNUIsRUFBRSxnQkFBZ0IsRUFBRSxvQkFBb0IsRUFBaUIsRUFDekQsR0FBaUQsRUFDakQsVUFBc0I7SUFFdEIsNERBQTREO0lBQzVELEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLDRCQUE0QixDQUFDLENBQUE7SUFFdkUsd0ZBQXdGO0lBQ3hGLGdFQUFnRTtJQUNoRSxLQUFLLENBQ0gsb0JBQW9CLEtBQUssS0FBSyxJQUFJLG9CQUFvQixJQUFJLENBQUMsRUFDM0QscUNBQXFDLENBQ3RDLENBQUE7SUFFRCwwRkFBMEY7SUFDMUYsR0FBRztRQUNELEdBQUcsWUFBWSxnQkFBZ0I7WUFDN0IsQ0FBQyxDQUFDLElBQUksNkNBQTZDLENBQUMsR0FBRyxDQUFDO1lB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