"use strict";
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports._decrypt = void 0;
const material_management_browser_1 = require("@aws-crypto/material-management-browser");
const serialize_1 = require("@aws-crypto/serialize");
const util_utf8_browser_1 = require("@aws-sdk/util-utf8-browser");
const deserialize = (0, serialize_1.deserializeFactory)(util_utf8_browser_1.toUtf8, material_management_browser_1.WebCryptoAlgorithmSuite);
const { messageAADContentString, messageAAD } = (0, serialize_1.aadFactory)(util_utf8_browser_1.fromUtf8);
async function _decrypt({ commitmentPolicy, maxEncryptedDataKeys }, cmm, ciphertext) {
    /* Precondition: _decrypt needs a valid commitmentPolicy. */
    (0, material_management_browser_1.needs)(material_management_browser_1.CommitmentPolicy[commitmentPolicy], 'Invalid commitment policy.');
    // buildDecrypt defaults this to false for backwards compatibility, so this is satisfied
    /* Precondition: _decrypt needs a valid maxEncryptedDataKeys. */
    (0, material_management_browser_1.needs)(maxEncryptedDataKeys === false || maxEncryptedDataKeys >= 1, 'Invalid maxEncryptedDataKeys value.');
    /* If the cmm is a Keyring, wrap it with WebCryptoDefaultCryptographicMaterialsManager. */
    cmm =
        cmm instanceof material_management_browser_1.KeyringWebCrypto
            ? new material_management_browser_1.WebCryptoDefaultCryptographicMaterialsManager(cmm)
            : cmm;
    const headerInfo = deserialize.deserializeMessageHeader(ciphertext, {
        maxEncryptedDataKeys,
    });
    if (headerInfo === false)
        throw new Error('Unable to parse Header');
    const { messageHeader, algorithmSuite } = headerInfo;
    const { rawHeader, headerAuth } = headerInfo;
    const { headerIv, headerAuthTag } = headerAuth;
    const { encryptionContext, encryptedDataKeys, suiteId, messageId } = messageHeader;
    // Very quick hex string
    const messageIdStr = [...messageId]
        .map((i) => (i > 15 ? i.toString(16) : '0' + i.toString(16)))
        .join('');
    /* Precondition: The parsed header algorithmSuite in _decrypt must be supported by the commitmentPolicy. */
    material_management_browser_1.CommitmentPolicySuites.isDecryptEnabled(commitmentPolicy, algorithmSuite, messageIdStr);
    const suite = new material_management_browser_1.WebCryptoAlgorithmSuite(suiteId);
    const material = await cmm.decryptMaterials({
        suite,
        encryptionContext,
        encryptedDataKeys,
    });
    /* Precondition: The material algorithmSuite returned to _decrypt must be supported by the commitmentPolicy. */
    material_management_browser_1.CommitmentPolicySuites.isDecryptEnabled(commitmentPolicy, material.suite, messageIdStr);
    const { getDecryptInfo, subtleVerify, dispose } = await (0, material_management_browser_1.getDecryptionHelper)(material);
    const getSubtleDecrypt = await getDecryptInfo(messageId, messageHeader.suiteData);
    // The tag is appended to the Data
    await getSubtleDecrypt(headerIv, rawHeader)(headerAuthTag); // will throw if invalid
    const { plaintext, readPos } = await bodyDecrypt({
        buffer: ciphertext,
        getSubtleDecrypt,
        headerInfo,
    });
    dispose();
    if (subtleVerify) {
        const data = ciphertext.slice(0, readPos);
        const signatureInfo = ciphertext.slice(readPos);
        const derSignature = (0, serialize_1.deserializeSignature)(signatureInfo);
        const rawSignature = (0, serialize_1.der2raw)(derSignature, material.suite);
        const isValid = await subtleVerify(rawSignature, data);
        /* Postcondition: subtleVerify must validate the signature. */
        (0, material_management_browser_1.needs)(isValid, 'Invalid Signature');
        return { messageHeader, plaintext };
    }
    else {
        return { messageHeader, plaintext };
    }
}
exports._decrypt = _decrypt;
async function bodyDecrypt({ buffer, getSubtleDecrypt, headerInfo, }) {
    let readPos = headerInfo.rawHeader.byteLength + headerInfo.headerAuth.headerAuthLength;
    const clearBuffers = [];
    let sequenceNumber = 0;
    // This is unfortunate, ideally the eslint no-constant-condition could be resolve
    // but at this time, I'm just going to disable this line
    // and leave a note to keep myself from replicating this kind of logic.
    /* eslint-disable no-constant-condition */
    while (true) {
        /* eslint-enable no-constant-condition */
        /* Keeping track of the sequence number myself. */
        sequenceNumber += 1;
        const { clearBlob, frameInfo } = await framedDecrypt({
            buffer,
            getSubtleDecrypt,
            headerInfo,
            readPos,
        });
        /* Precondition: The sequenceNumber is required to monotonically increase, starting from 1.
         * This is to avoid a bad actor from abusing the sequence number on un-signed algorithm suites.
         * If the frame size matched the data format (say NDJSON),
         * then the data could be significantly altered just by rearranging the frames.
         * Non-framed data returns a sequenceNumber of 1.
         */
        (0, material_management_browser_1.needs)(frameInfo.sequenceNumber === sequenceNumber, 'Encrypted body sequence out of order.');
        clearBuffers.push(clearBlob);
        readPos = frameInfo.readPos;
        if (frameInfo.isFinalFrame) {
            const plaintext = (0, serialize_1.concatBuffers)(...clearBuffers);
            return { plaintext, readPos };
        }
    }
}
/* As we move to deprecate non-framed encrypt it is important to continue to support
 * non-framed decrypt.  The names not-withstanding, this supports non-framed decrypt
 * See decodeBodyHeader (it abstracts framed and non-framed body headers)
 */
async function framedDecrypt({ buffer, getSubtleDecrypt, headerInfo, readPos, }) {
    const { messageHeader: { messageId }, } = headerInfo;
    const frameInfo = (0, serialize_1.decodeBodyHeader)(buffer, headerInfo, readPos);
    if (!frameInfo)
        throw new Error('Format Error');
    const cipherLength = frameInfo.contentLength + frameInfo.tagLength / 8;
    const contentString = messageAADContentString(frameInfo);
    const messageAdditionalData = messageAAD(messageId, contentString, frameInfo.sequenceNumber, frameInfo.contentLength);
    const cipherBlob = buffer.slice(frameInfo.readPos, frameInfo.readPos + cipherLength);
    const clearBlob = await getSubtleDecrypt(frameInfo.iv, messageAdditionalData)(cipherBlob);
    frameInfo.readPos += cipherLength;
    return { clearBlob, frameInfo };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjcnlwdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kZWNyeXB0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxvRUFBb0U7QUFDcEUsc0NBQXNDOzs7QUFFdEMseUZBV2dEO0FBQ2hELHFEQVU4QjtBQUM5QixrRUFBNkQ7QUFFN0QsTUFBTSxXQUFXLEdBQUcsSUFBQSw4QkFBa0IsRUFBQywwQkFBTSxFQUFFLHFEQUF1QixDQUFDLENBQUE7QUFDdkUsTUFBTSxFQUFFLHVCQUF1QixFQUFFLFVBQVUsRUFBRSxHQUFHLElBQUEsc0JBQVUsRUFBQyw0QkFBUSxDQUFDLENBQUE7QUFPN0QsS0FBSyxVQUFVLFFBQVEsQ0FDNUIsRUFBRSxnQkFBZ0IsRUFBRSxvQkFBb0IsRUFBaUIsRUFDekQsR0FBaUQsRUFDakQsVUFBc0I7SUFFdEIsNERBQTREO0lBQzVELElBQUEsbUNBQUssRUFBQyw4Q0FBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLDRCQUE0QixDQUFDLENBQUE7SUFFdkUsd0ZBQXdGO0lBQ3hGLGdFQUFnRTtJQUNoRSxJQUFBLG1DQUFLLEVBQ0gsb0JBQW9CLEtBQUssS0FBSyxJQUFJLG9CQUFvQixJQUFJLENBQUMsRUFDM0QscUNBQXFDLENBQ3RDLENBQUE7SUFFRCwwRkFBMEY7SUFDMUYsR0FBRztRQUNELEdBQUcsWUFBWSw4Q0FBZ0I7WUFDN0IsQ0FBQyxDQUFDLElBQUksMkVBQTZDLENBQUMsR0FBRyxDQUFDO1lBQ3hELENBQUMsQ0FBQyxHQUFHLENBQUE7SUFFVCxNQUFNLFVBQVUsR0FBRyxXQUFXLENBQUMsd0JBQXdCLENBQUMsVUFBVSxFQUFFO1FBQ2xFLG9CQUFvQjtLQUNyQixDQUFDLENBQUE7SUFDRixJQUFJLFVBQVUsS0FBSyxLQUFLO1FBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQyxDQUFBO0lBQ25FLE1BQU0sRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFLEdBQUcsVUFBVSxD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