// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { KeyringWebCrypto, needs, KeyringTraceFlag, immutableClass, readOnlyProperty, currySubtleFunction, _importCryptoKey, unwrapDataKey, importForWebCryptoEncryptionMaterial, importForWebCryptoDecryptionMaterial, } from '@aws-crypto/material-management-browser';
import { serializeFactory, concatBuffers } from '@aws-crypto/serialize';
import { _onEncrypt, _onDecrypt, WebCryptoRawAesMaterial, rawAesEncryptedDataKeyFactory, rawAesEncryptedPartsFactory, } from '@aws-crypto/raw-keyring';
import { fromUtf8, toUtf8 } from '@aws-sdk/util-utf8-browser';
import { randomValuesOnly } from '@aws-crypto/random-source-browser';
import { getWebCryptoBackend, getNonZeroByteBackend, } from '@aws-crypto/web-crypto-backend';
const { serializeEncryptionContext } = serializeFactory(fromUtf8);
const { rawAesEncryptedDataKey } = rawAesEncryptedDataKeyFactory(toUtf8, fromUtf8);
const { rawAesEncryptedParts } = rawAesEncryptedPartsFactory(fromUtf8);
const encryptFlags = KeyringTraceFlag.WRAPPING_KEY_ENCRYPTED_DATA_KEY |
    KeyringTraceFlag.WRAPPING_KEY_SIGNED_ENC_CTX;
const decryptFlags = KeyringTraceFlag.WRAPPING_KEY_DECRYPTED_DATA_KEY |
    KeyringTraceFlag.WRAPPING_KEY_VERIFIED_ENC_CTX;
export class RawAesKeyringWebCrypto extends KeyringWebCrypto {
    constructor(input) {
        super();
        const { keyName, keyNamespace, masterKey, wrappingSuite } = input;
        /* Precondition: AesKeyringWebCrypto needs identifying information for encrypt and decrypt. */
        needs(keyName && keyNamespace, 'Identifying information must be defined.');
        /* Precondition: RawAesKeyringWebCrypto requires a wrappingSuite to be a valid RawAesWrappingSuite. */
        const wrappingMaterial = new WebCryptoRawAesMaterial(wrappingSuite)
            /* Precondition: unencryptedMasterKey must correspond to the WebCryptoAlgorithmSuite specification.
             * Note: the KeyringTrace and flag are _only_ set because I am reusing an existing implementation.
             * See: raw_aes_material.ts in @aws-crypto/raw-keyring for details
             */
            .setCryptoKey(masterKey, {
            keyNamespace,
            keyName,
            flags: KeyringTraceFlag.WRAPPING_KEY_GENERATED_DATA_KEY,
        });
        const _wrapKey = async (material) => {
            /* The AAD section is uInt16BE(length) + AAD
             * see: https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html#header-aad
             * However, the RAW Keyring wants _only_ the ADD.
             * So, I just slice off the length.
             */
            const aad = serializeEncryptionContext(material.encryptionContext).slice(2);
            const { keyNamespace, keyName } = this;
            return aesGcmWrapKey(keyNamespace, keyName, material, aad, wrappingMaterial);
        };
        const _unwrapKey = async (material, edk) => {
            /* The AAD section is uInt16BE(length) + AAD
             * see: https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html#header-aad
             * However, the RAW Keyring wants _only_ the ADD.
             * So, I just slice off the length.
             */
            const aad = serializeEncryptionContext(material.encryptionContext).slice(2);
            const { keyNamespace, keyName } = this;
            return aesGcmUnwrapKey(keyNamespace, keyName, material, wrappingMaterial, edk, aad);
        };
        readOnlyProperty(this, 'keyName', keyName);
        readOnlyProperty(this, 'keyNamespace', keyNamespace);
        readOnlyProperty(this, '_wrapKey', _wrapKey);
        readOnlyProperty(this, '_unwrapKey', _unwrapKey);
    }
    _filter({ providerId, providerInfo }) {
        const { keyNamespace, keyName } = this;
        return providerId === keyNamespace && providerInfo.startsWith(keyName);
    }
    _rawOnEncrypt = _onEncrypt(randomValuesOnly);
    _onEncrypt = async (material) => {
        const _material = await this._rawOnEncrypt(material);
        return importForWebCryptoEncryptionMaterial(_material);
    };
    /* onDecrypt does not need to import the crypto key, because this is handled in the unwrap operation
     * Encrypt needs to have access to the unencrypted data key to encrypt with other keyrings
     * but once I have functional material no other decrypt operations need to be performed.
     */
    _onDecrypt = _onDecrypt();
    static async importCryptoKey(masterKey, wrappingSuite) {
        needs(masterKey instanceof Uint8Array, 'Unsupported master key type.');
        const material = new WebCryptoRawAesMaterial(wrappingSuite)
            /* Precondition: masterKey must correspond to the algorithm suite specification.
             * Note: the KeyringTrace and flag are _only_ set because I am reusing an existing implementation.
             * See: raw_aes_material.ts in @aws-crypto/raw-keyring for details
             */
            .setUnencryptedDataKey(masterKey, {
            keyNamespace: 'importOnly',
            keyName: 'importOnly',
            flags: KeyringTraceFlag.WRAPPING_KEY_GENERATED_DATA_KEY,
        });
        return backendForRawAesMasterKey().then(async (backend) => _importCryptoKey(backend.subtle, material, ['encrypt', 'decrypt']));
    }
}
immutableClass(RawAesKeyringWebCrypto);
/**
 * Uses aes-gcm to encrypt the data key and return the passed WebCryptoEncryptionMaterial with
 * an EncryptedDataKey added.
 * @param keyNamespace [String] The keyring namespace (for KeyringTrace)
 * @param keyName [String] The keyring name (for KeyringTrace and to extract the extra info stored in providerInfo)
 * @param material [WebCryptoEncryptionMaterial] The target material to which the EncryptedDataKey will be added
 * @param aad [Uint8Array] The serialized aad (EncryptionContext)
 * @param wrappingMaterial [WebCryptoRawAesMaterial] The material used to decrypt the EncryptedDataKey
 * @returns [WebCryptoEncryptionMaterial] Mutates and returns the same WebCryptoEncryptionMaterial that was passed but with an EncryptedDataKey added
 */
async function aesGcmWrapKey(keyNamespace, keyName, material, aad, wrappingMaterial) {
    const backend = await backendForRawAesMasterKey();
    const iv = await backend.randomValues(material.suite.ivLength);
    const getSubtleInfo = currySubtleFunction(wrappingMaterial, backend, 'encrypt');
    const info = new Uint8Array();
    const { getSubtleEncrypt } = await getSubtleInfo(info);
    const dataKey = unwrapDataKey(material.getUnencryptedDataKey());
    const buffer = await getSubtleEncrypt(iv, aad)(dataKey);
    const ciphertext = new Uint8Array(buffer, 0, buffer.byteLength - material.suite.tagLength / 8);
    const authTag = new Uint8Array(buffer, buffer.byteLength - material.suite.tagLength / 8);
    const edk = rawAesEncryptedDataKey(keyNamespace, keyName, iv, ciphertext, authTag);
    return material.addEncryptedDataKey(edk, encryptFlags);
}
/**
 * Uses aes-gcm to decrypt the encrypted data key and return the passed WebCryptoDecryptionMaterial with
 * the unencrypted data key set.
 * @param keyNamespace [String] The keyring namespace (for KeyringTrace)
 * @param keyName [String] The keyring name (for KeyringTrace and to extract the extra info stored in providerInfo)
 * @param material [WebCryptoDecryptionMaterial] The target material to which the decrypted data key will be added
 * @param wrappingMaterial [WebCryptoRawAesMaterial] The material used to decrypt the EncryptedDataKey
 * @param edk [EncryptedDataKey] The EncryptedDataKey on which to operate
 * @param aad [Uint8Array] The serialized aad (EncryptionContext)
 * @returns [WebCryptoDecryptionMaterial] Mutates and returns the same WebCryptoDecryptionMaterial that was passed but with the unencrypted data key set
 */
async function aesGcmUnwrapKey(keyNamespace, keyName, material, wrappingMaterial, edk, aad) {
    const { suite } = material;
    const { iv, ciphertext, authTag } = rawAesEncryptedParts(suite, keyName, edk);
    const backend = await backendForRawAesMasterKey();
    const getSubtleInfo = currySubtleFunction(wrappingMaterial, backend, 'decrypt');
    const info = new Uint8Array();
    const getSubtleDecrypt = await getSubtleInfo(info);
    const buffer = await getSubtleDecrypt(iv, aad)(concatBuffers(ciphertext, authTag));
    const trace = { keyNamespace, keyName, flags: decryptFlags };
    material.setUnencryptedDataKey(new Uint8Array(buffer), trace);
    return importForWebCryptoDecryptionMaterial(material);
}
/**
 * The master key can not be zero length.
 * If the back end is mixed,
 * to support both zero and non-zero byte AES-GCM operations,
 * then the `NonZeroByteBackend` should be the native implementation.
 * I assert that it should be slightly harder to exfiltrate
 * from the native implementation than a JS implementation.
 * So I *force* the master key to be stored in the native implementation **only**.
 */
async function backendForRawAesMasterKey() {
    const backend = await getWebCryptoBackend();
    const { randomValues } = backend;
    const subtle = getNonZeroByteBackend(backend);
    return { randomValues, subtle };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmF3X2Flc19rZXlyaW5nX2Jyb3dzZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcmF3X2Flc19rZXlyaW5nX2Jyb3dzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsb0VBQW9FO0FBQ3BFLHNDQUFzQztBQUV0QyxPQUFPLEVBQ0wsZ0JBQWdCLEVBQ2hCLEtBQUssRUFJTCxnQkFBZ0IsRUFDaEIsY0FBYyxFQUNkLGdCQUFnQixFQUVoQixtQkFBbUIsRUFDbkIsZ0JBQWdCLEVBQ2hCLGFBQWEsRUFDYixvQ0FBb0MsRUFDcEMsb0NBQW9DLEdBRXJDLE1BQU0seUNBQXlDLENBQUE7QUFDaEQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLGFBQWEsRUFBRSxNQUFNLHVCQUF1QixDQUFBO0FBQ3ZFLE9BQU8sRUFDTCxVQUFVLEVBQ1YsVUFBVSxFQUNWLHVCQUF1QixFQUN2Qiw2QkFBNkIsRUFDN0IsMkJBQTJCLEdBSTVCLE1BQU0seUJBQXlCLENBQUE7QUFDaEMsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQTtBQUM3RCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQTtBQUNwRSxPQUFPLEVBQ0wsbUJBQW1CLEVBQ25CLHFCQUFxQixHQUN0QixNQUFNLGdDQUFnQyxDQUFBO0FBQ3ZDLE1BQU0sRUFBRSwwQkFBMEIsRUFBRSxHQUFHLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFBO0FBQ2pFLE1BQU0sRUFBRSxzQkFBc0IsRUFBRSxHQUFHLDZCQUE2QixDQUM5RCxNQUFNLEVBQ04sUUFBUSxDQUNULENBQUE7QUFDRCxNQUFNLEVBQUUsb0JBQW9CLEVBQUUsR0FBRywyQkFBMkIsQ0FBQyxRQUFRLENBQUMsQ0FBQTtBQUN0RSxNQUFNLFlBQVksR0FDaEIsZ0JBQWdCLENBQUMsK0JBQStCO0lBQ2hELGdCQUFnQixDQUFDLDJCQUEyQixDQUFBO0FBQzlDLE1BQU0sWUFB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