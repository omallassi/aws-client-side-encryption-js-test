"use strict";
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.RawAesKeyringWebCrypto = void 0;
const material_management_browser_1 = require("@aws-crypto/material-management-browser");
const serialize_1 = require("@aws-crypto/serialize");
const raw_keyring_1 = require("@aws-crypto/raw-keyring");
const util_utf8_browser_1 = require("@aws-sdk/util-utf8-browser");
const random_source_browser_1 = require("@aws-crypto/random-source-browser");
const web_crypto_backend_1 = require("@aws-crypto/web-crypto-backend");
const { serializeEncryptionContext } = (0, serialize_1.serializeFactory)(util_utf8_browser_1.fromUtf8);
const { rawAesEncryptedDataKey } = (0, raw_keyring_1.rawAesEncryptedDataKeyFactory)(util_utf8_browser_1.toUtf8, util_utf8_browser_1.fromUtf8);
const { rawAesEncryptedParts } = (0, raw_keyring_1.rawAesEncryptedPartsFactory)(util_utf8_browser_1.fromUtf8);
const encryptFlags = material_management_browser_1.KeyringTraceFlag.WRAPPING_KEY_ENCRYPTED_DATA_KEY |
    material_management_browser_1.KeyringTraceFlag.WRAPPING_KEY_SIGNED_ENC_CTX;
const decryptFlags = material_management_browser_1.KeyringTraceFlag.WRAPPING_KEY_DECRYPTED_DATA_KEY |
    material_management_browser_1.KeyringTraceFlag.WRAPPING_KEY_VERIFIED_ENC_CTX;
class RawAesKeyringWebCrypto extends material_management_browser_1.KeyringWebCrypto {
    constructor(input) {
        super();
        const { keyName, keyNamespace, masterKey, wrappingSuite } = input;
        /* Precondition: AesKeyringWebCrypto needs identifying information for encrypt and decrypt. */
        (0, material_management_browser_1.needs)(keyName && keyNamespace, 'Identifying information must be defined.');
        /* Precondition: RawAesKeyringWebCrypto requires a wrappingSuite to be a valid RawAesWrappingSuite. */
        const wrappingMaterial = new raw_keyring_1.WebCryptoRawAesMaterial(wrappingSuite)
            /* Precondition: unencryptedMasterKey must correspond to the WebCryptoAlgorithmSuite specification.
             * Note: the KeyringTrace and flag are _only_ set because I am reusing an existing implementation.
             * See: raw_aes_material.ts in @aws-crypto/raw-keyring for details
             */
            .setCryptoKey(masterKey, {
            keyNamespace,
            keyName,
            flags: material_management_browser_1.KeyringTraceFlag.WRAPPING_KEY_GENERATED_DATA_KEY,
        });
        const _wrapKey = async (material) => {
            /* The AAD section is uInt16BE(length) + AAD
             * see: https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html#header-aad
             * However, the RAW Keyring wants _only_ the ADD.
             * So, I just slice off the length.
             */
            const aad = serializeEncryptionContext(material.encryptionContext).slice(2);
            const { keyNamespace, keyName } = this;
            return aesGcmWrapKey(keyNamespace, keyName, material, aad, wrappingMaterial);
        };
        const _unwrapKey = async (material, edk) => {
            /* The AAD section is uInt16BE(length) + AAD
             * see: https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html#header-aad
             * However, the RAW Keyring wants _only_ the ADD.
             * So, I just slice off the length.
             */
            const aad = serializeEncryptionContext(material.encryptionContext).slice(2);
            const { keyNamespace, keyName } = this;
            return aesGcmUnwrapKey(keyNamespace, keyName, material, wrappingMaterial, edk, aad);
        };
        (0, material_management_browser_1.readOnlyProperty)(this, 'keyName', keyName);
        (0, material_management_browser_1.readOnlyProperty)(this, 'keyNamespace', keyNamespace);
        (0, material_management_browser_1.readOnlyProperty)(this, '_wrapKey', _wrapKey);
        (0, material_management_browser_1.readOnlyProperty)(this, '_unwrapKey', _unwrapKey);
    }
    _filter({ providerId, providerInfo }) {
        const { keyNamespace, keyName } = this;
        return providerId === keyNamespace && providerInfo.startsWith(keyName);
    }
    _rawOnEncrypt = (0, raw_keyring_1._onEncrypt)(random_source_browser_1.randomValuesOnly);
    _onEncrypt = async (material) => {
        const _material = await this._rawOnEncrypt(material);
        return (0, material_management_browser_1.importForWebCryptoEncryptionMaterial)(_material);
    };
    /* onDecrypt does not need to import the crypto key, because this is handled in the unwrap operation
     * Encrypt needs to have access to the unencrypted data key to encrypt with other keyrings
     * but once I have functional material no other decrypt operations need to be performed.
     */
    _onDecrypt = (0, raw_keyring_1._onDecrypt)();
    static async importCryptoKey(masterKey, wrappingSuite) {
        (0, material_management_browser_1.needs)(masterKey instanceof Uint8Array, 'Unsupported master key type.');
        const material = new raw_keyring_1.WebCryptoRawAesMaterial(wrappingSuite)
            /* Precondition: masterKey must correspond to the algorithm suite specification.
             * Note: the KeyringTrace and flag are _only_ set because I am reusing an existing implementation.
             * See: raw_aes_material.ts in @aws-crypto/raw-keyring for details
             */
            .setUnencryptedDataKey(masterKey, {
            keyNamespace: 'importOnly',
            keyName: 'importOnly',
            flags: material_management_browser_1.KeyringTraceFlag.WRAPPING_KEY_GENERATED_DATA_KEY,
        });
        return backendForRawAesMasterKey().then(async (backend) => (0, material_management_browser_1._importCryptoKey)(backend.subtle, material, ['encrypt', 'decrypt']));
    }
}
exports.RawAesKeyringWebCrypto = RawAesKeyringWebCrypto;
(0, material_management_browser_1.immutableClass)(RawAesKeyringWebCrypto);
/**
 * Uses aes-gcm to encrypt the data key and return the passed WebCryptoEncryptionMaterial with
 * an EncryptedDataKey added.
 * @param keyNamespace [String] The keyring namespace (for KeyringTrace)
 * @param keyName [String] The keyring name (for KeyringTrace and to extract the extra info stored in providerInfo)
 * @param material [WebCryptoEncryptionMaterial] The target material to which the EncryptedDataKey will be added
 * @param aad [Uint8Array] The serialized aad (EncryptionContext)
 * @param wrappingMaterial [WebCryptoRawAesMaterial] The material used to decrypt the EncryptedDataKey
 * @returns [WebCryptoEncryptionMaterial] Mutates and returns the same WebCryptoEncryptionMaterial that was passed but with an EncryptedDataKey added
 */
async function aesGcmWrapKey(keyNamespace, keyName, material, aad, wrappingMaterial) {
    const backend = await backendForRawAesMasterKey();
    const iv = await backend.randomValues(material.suite.ivLength);
    const getSubtleInfo = (0, material_management_browser_1.currySubtleFunction)(wrappingMaterial, backend, 'encrypt');
    const info = new Uint8Array();
    const { getSubtleEncrypt } = await getSubtleInfo(info);
    const dataKey = (0, material_management_browser_1.unwrapDataKey)(material.getUnencryptedDataKey());
    const buffer = await getSubtleEncrypt(iv, aad)(dataKey);
    const ciphertext = new Uint8Array(buffer, 0, buffer.byteLength - material.suite.tagLength / 8);
    const authTag = new Uint8Array(buffer, buffer.byteLength - material.suite.tagLength / 8);
    const edk = rawAesEncryptedDataKey(keyNamespace, keyName, iv, ciphertext, authTag);
    return material.addEncryptedDataKey(edk, encryptFlags);
}
/**
 * Uses aes-gcm to decrypt the encrypted data key and return the passed WebCryptoDecryptionMaterial with
 * the unencrypted data key set.
 * @param keyNamespace [String] The keyring namespace (for KeyringTrace)
 * @param keyName [String] The keyring name (for KeyringTrace and to extract the extra info stored in providerInfo)
 * @param material [WebCryptoDecryptionMaterial] The target material to which the decrypted data key will be added
 * @param wrappingMaterial [WebCryptoRawAesMaterial] The material used to decrypt the EncryptedDataKey
 * @param edk [EncryptedDataKey] The EncryptedDataKey on which to operate
 * @param aad [Uint8Array] The serialized aad (EncryptionContext)
 * @returns [WebCryptoDecryptionMaterial] Mutates and returns the same WebCryptoDecryptionMaterial that was passed but with the unencrypted data key set
 */
async function aesGcmUnwrapKey(keyNamespace, keyName, material, wrappingMaterial, edk, aad) {
    const { suite } = material;
    const { iv, ciphertext, authTag } = rawAesEncryptedParts(suite, keyName, edk);
    const backend = await backendForRawAesMasterKey();
    const getSubtleInfo = (0, material_management_browser_1.currySubtleFunction)(wrappingMaterial, backend, 'decrypt');
    const info = new Uint8Array();
    const getSubtleDecrypt = await getSubtleInfo(info);
    const buffer = await getSubtleDecrypt(iv, aad)((0, serialize_1.concatBuffers)(ciphertext, authTag));
    const trace = { keyNamespace, keyName, flags: decryptFlags };
    material.setUnencryptedDataKey(new Uint8Array(buffer), trace);
    return (0, material_management_browser_1.importForWebCryptoDecryptionMaterial)(material);
}
/**
 * The master key can not be zero length.
 * If the back end is mixed,
 * to support both zero and non-zero byte AES-GCM operations,
 * then the `NonZeroByteBackend` should be the native implementation.
 * I assert that it should be slightly harder to exfiltrate
 * from the native implementation than a JS implementation.
 * So I *force* the master key to be stored in the native implementation **only**.
 */
async function backendForRawAesMasterKey() {
    const backend = await (0, web_crypto_backend_1.getWebCryptoBackend)();
    const { randomValues } = backend;
    const subtle = (0, web_crypto_backend_1.getNonZeroByteBackend)(backend);
    return { randomValues, subtle };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmF3X2Flc19rZXlyaW5nX2Jyb3dzZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcmF3X2Flc19rZXlyaW5nX2Jyb3dzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLG9FQUFvRTtBQUNwRSxzQ0FBc0M7OztBQUV0Qyx5RkFnQmdEO0FBQ2hELHFEQUF1RTtBQUN2RSx5REFTZ0M7QUFDaEMsa0VBQTZEO0FBQzdELDZFQUFvRTtBQUNwRSx1RUFHdUM7QUFDdkMsTUFBTSxFQUFFLDBCQUEwQixFQUFFLEdBQUcsSUFBQSw0QkFBZ0IsRUFBQyw0QkFBUSxDQUFDLENBQUE7QUFDakUsTUFBTSxFQUFFLHNCQUFzQixFQUFFLEdBQUcsSUFBQSwyQ0FBNkIsRUFDOUQsMEJBQU0sRUFDTiw0QkFBUSxDQUNULENBQUE7QUFDRCxNQUFNLEVBQUUsb0JBQW9CLEVBQUUsR0FBRyxJQUFBLHlDQUEyQixFQUFDLDRCQUFRLENBQUMsQ0FBQTtBQUN0RSxNQUFNLFlBQVksR0FDaEIsOENBQWdCLENBQUMsK0JBQStCO0lBQ2hELDhDQUFnQixDQUFDLDJCQUEyQixDQUFBO0FBQzlDLE1BQU0sWUFBWSxHQUNoQiw4Q0FBZ0IsQ0FBQywrQkFBK0I7SUFDaEQsOENBQWdCLENBQUMsNkJBQTZCLENBQUE7QUFTaEQsTUFBYSxzQkFBdUIsU0FBUSw4Q0FBZ0I7SUFNMUQsWUFBWSxLQUFrQztRQUM1QyxLQUFLLEVBQUUsQ0FBQTtRQUNQLE1BQU0sRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxhQUFhLEVBQUUsR0FBRyxLQUFLLENBQUE7UUFDakUsOEZBQThGO1FBQzlGLElBQUEsbUNBQUssRUFBQyxPQUFPLElBQUksWUFBWSxFQUFFLDBDQUEwQyxDQUFDLENBQUE7UUFDMUUsc0dBQXNHO1FBQ3RHLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxxQ0FBdUIsQ0FBQyxhQUFhLENBQUM7WUFDakU7OztlQUdHO2FBQ0YsWUFBWSxDQUFD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